<head>
  <script>
    var raw = [{"id":"1-1397415736689","name":"lunr","signiture":"lunr()","type":"function","ctx":{"type":"function","name":"lunr","string":"lunr()"},"description":{"full":"<p>Convenience function for instantiating a new lunr index and configuring it<br />with the default pipeline functions and the passed config function.</p>\n\n<p>When using this convenience function a new index will be created with the<br />following functions already in the pipeline:</p>\n\n<p>lunr.StopWordFilter - filters out any stop words before they enter the<br />index</p>\n\n<p>lunr.stemmer - stems the tokens before entering the index.</p>\n\n<p>Example:</p>\n\n<pre><code>var idx = lunr(function () {\n  this.field('title', 10)\n  this.field('tags', 100)\n  this.field('body')\n\n  this.ref('cid')\n\n  this.pipeline.add(function () {\n    // some custom pipeline function\n  })\n\n})\n</code></pre>","summary":"<p>Convenience function for instantiating a new lunr index and configuring it<br />with the default pipeline functions and the passed config function.</p>","body":"<p>When using this convenience function a new index will be created with the<br />following functions already in the pipeline:</p>\n\n<p>lunr.StopWordFilter - filters out any stop words before they enter the<br />index</p>\n\n<p>lunr.stemmer - stems the tokens before entering the index.</p>\n\n<p>Example:</p>\n\n<pre><code>var idx = lunr(function () {\n  this.field('title', 10)\n  this.field('tags', 100)\n  this.field('body')\n\n  this.ref('cid')\n\n  this.pipeline.add(function () {\n    // some custom pipeline function\n  })\n\n})\n</code></pre>"},"full_description":"<p>Convenience function for instantiating a new lunr index and configuring it with the default pipeline functions and the passed config function.</p>\n\n<p>When using this convenience function a new index will be created with the following functions already in the pipeline:</p>\n\n<p>lunr.StopWordFilter - filters out any stop words before they enter the index</p>\n\n<p>lunr.stemmer - stems the tokens before entering the index.</p>\n\n<p>Example:</p>\n\n<pre><code>var idx = lunr(function () {\n  this.field('title', 10)\n  this.field('tags', 100)\n  this.field('body')\n\n  this.ref('cid')\n\n  this.pipeline.add(function () {\n    // some custom pipeline function\n  })\n\n})\n</code></pre>","code":"var lunr = function (config) {\n  var idx = new lunr.Index\n\n  idx.indexPipeline.add(\n    lunr.trimmer,\n    lunr.stopWordFilter,\n    lunr.stemmer\n  )\n\n  idx.searchPipeline.add(\n    lunr.trimmer,\n    lunr.stopWordFilter,\n    lunr.stemmer\n  )\n\n  if (config) config.call(idx, idx)\n\n  return idx\n}\n\nlunr.version = \"0.5.0\"","params":[{"type":"param","types":["Function"],"name":"config","description":"A function that will be called with the new instance"}],"has_params":true,"tags":[{"type":"param","types":["Function"],"name":"config","description":"A function that will be called with the new instance"},{"type":"of","string":"the lunr.Index as both its context and first parameter. It can be used to"},{"type":"customize","string":"the instance of new lunr.Index."},{"type":"namespace","string":""},{"type":"module","string":""},{"type":"returns","string":"{lunr.Index}"}],"module":true,"related":{"href":""},"has_related":true,"methods":[]},{"id":"4-1397415736689","name":"EventEmitter","signiture":"lunr.EventEmitter()","type":"method","ctx":{"type":"method","receiver":"lunr","name":"EventEmitter","string":"lunr.EventEmitter()"},"description":{"full":"<p>lunr.EventEmitter is an event emitter for lunr. It manages adding and removing event handlers and triggering events and their handlers.</p>","summary":"<p>lunr.EventEmitter is an event emitter for lunr. It manages adding and removing event handlers and triggering events and their handlers.</p>","body":""},"full_description":"<p>lunr.EventEmitter is an event emitter for lunr. It manages adding and removing event handlers and triggering events and their handlers.</p>","code":"lunr.EventEmitter = function () {\n  this.events = {}\n}","params":[],"has_params":false,"tags":[{"type":"constructor","string":""}],"module":true,"related":{"href":""},"has_related":true,"methods":[{"id":"5-1397415736689","name":"addListener","signiture":"lunr.EventEmitter.prototype.addListener()","type":"method","ctx":{"type":"method","receiver":"lunr.EventEmitter.prototype","name":"addListener","string":"lunr.EventEmitter.prototype.addListener()"},"description":{"full":"<p>Binds a handler function to a specific event(s).</p>\n\n<p>Can bind a single function to many different events in one call.</p>","summary":"<p>Binds a handler function to a specific event(s).</p>","body":"<p>Can bind a single function to many different events in one call.</p>"},"full_description":"<p>Binds a handler function to a specific event(s).</p>\n\n<p>Can bind a single function to many different events in one call.</p>","code":"lunr.EventEmitter.prototype.addListener = function () {\n  var args = Array.prototype.slice.call(arguments),\n      fn = args.pop(),\n      names = args\n\n  if (typeof fn !== \"function\") throw new TypeError (\"last argument must be a function\")\n\n  names.forEach(function (name) {\n    if (!this.hasHandler(name)) this.events[name] = []\n    this.events[name].push(fn)\n  }, this)\n}","params":[{"type":"param","types":["String"],"name":"[eventName]","description":"The name(s) of events to bind this function to."},{"type":"param","types":["Function"],"name":"handler","description":"The function to call when an event is fired."}],"has_params":true,"tags":[{"type":"param","types":["String"],"name":"[eventName]","description":"The name(s) of events to bind this function to."},{"type":"param","types":["Function"],"name":"handler","description":"The function to call when an event is fired."},{"type":"memberOf","parent":"EventEmitter"}],"module":false,"parent":"EventEmitter","related":{"href":""},"has_related":true},{"id":"6-1397415736689","name":"removeListener","signiture":"lunr.EventEmitter.prototype.removeListener()","type":"method","ctx":{"type":"method","receiver":"lunr.EventEmitter.prototype","name":"removeListener","string":"lunr.EventEmitter.prototype.removeListener()"},"description":{"full":"<p>Removes a handler function from a specific event.</p>","summary":"<p>Removes a handler function from a specific event.</p>","body":""},"full_description":"<p>Removes a handler function from a specific event.</p>","code":"lunr.EventEmitter.prototype.removeListener = function (name, fn) {\n  if (!this.hasHandler(name)) return\n\n  var fnIndex = this.events[name].indexOf(fn)\n  this.events[name].splice(fnIndex, 1)\n\n  if (!this.events[name].length) delete this.events[name]\n}","params":[{"type":"param","types":["String"],"name":"eventName","description":"The name of the event to remove this function from."},{"type":"param","types":["Function"],"name":"handler","description":"The function to remove from an event."}],"has_params":true,"tags":[{"type":"param","types":["String"],"name":"eventName","description":"The name of the event to remove this function from."},{"type":"param","types":["Function"],"name":"handler","description":"The function to remove from an event."},{"type":"memberOf","parent":"EventEmitter"}],"module":false,"parent":"EventEmitter","related":{"href":""},"has_related":true},{"id":"7-1397415736689","name":"emit","signiture":"lunr.EventEmitter.prototype.emit()","type":"method","ctx":{"type":"method","receiver":"lunr.EventEmitter.prototype","name":"emit","string":"lunr.EventEmitter.prototype.emit()"},"description":{"full":"<p>Calls all functions bound to the given event.</p>\n\n<p>Additional data can be passed to the event handler as arguments to <code>emit</code><br />after the event name.</p>","summary":"<p>Calls all functions bound to the given event.</p>","body":"<p>Additional data can be passed to the event handler as arguments to <code>emit</code><br />after the event name.</p>"},"full_description":"<p>Calls all functions bound to the given event.</p>\n\n<p>Additional data can be passed to the event handler as arguments to <code>emit</code> after the event name.</p>","code":"lunr.EventEmitter.prototype.emit = function (name) {\n  if (!this.hasHandler(name)) return\n\n  var args = Array.prototype.slice.call(arguments, 1)\n\n  this.events[name].forEach(function (fn) {\n    fn.apply(undefined, args)\n  })\n}","params":[{"type":"param","types":["String"],"name":"eventName","description":"The name of the event to emit."}],"has_params":true,"tags":[{"type":"param","types":["String"],"name":"eventName","description":"The name of the event to emit."},{"type":"memberOf","parent":"EventEmitter"}],"module":false,"parent":"EventEmitter","related":{"href":""},"has_related":true},{"id":"8-1397415736689","name":"hasHandler","signiture":"lunr.EventEmitter.prototype.hasHandler()","type":"method","ctx":{"type":"method","receiver":"lunr.EventEmitter.prototype","name":"hasHandler","string":"lunr.EventEmitter.prototype.hasHandler()"},"description":{"full":"<p>Checks whether a handler has ever been stored against an event.</p>","summary":"<p>Checks whether a handler has ever been stored against an event.</p>","body":""},"full_description":"<p>Checks whether a handler has ever been stored against an event.</p>","code":"lunr.EventEmitter.prototype.hasHandler = function (name) {\n  return name in this.events\n}","params":[{"type":"param","types":["String"],"name":"eventName","description":"The name of the event to check."}],"has_params":true,"tags":[{"type":"param","types":["String"],"name":"eventName","description":"The name of the event to check."},{"type":"private","string":""},{"type":"memberOf","parent":"EventEmitter"}],"module":false,"parent":"EventEmitter","related":{"href":""},"has_related":true}]},{"id":"9-1397415736689","name":"tokenizer","signiture":"lunr.tokenizer()","type":"method","ctx":{"type":"method","receiver":"lunr","name":"tokenizer","string":"lunr.tokenizer()"},"description":{"full":"<p>A function for splitting a string into tokens ready to be inserted into<br />the search index.</p>","summary":"<p>A function for splitting a string into tokens ready to be inserted into<br />the search index.</p>","body":""},"full_description":"<p>A function for splitting a string into tokens ready to be inserted into the search index.</p>","code":"lunr.tokenizer = function (obj) {\n  if (!arguments.length || obj == null || obj == undefined) return []\n  if (Array.isArray(obj)) return obj.map(function (t) { return t.toLowerCase() })\n\n  var str = obj.toString().replace(/^\\s+/, '')\n\n  for (var i = str.length - 1; i >= 0; i--) {\n    if (/\\S/.test(str.charAt(i))) {\n      str = str.substring(0, i + 1)\n      break\n    }\n  }\n\n  return str\n    .split(/\\s+/)\n    .map(function (token) {\n      return token.toLowerCase()\n    })\n}","params":[{"type":"param","types":["String"],"name":"obj","description":"The string to convert into tokens"}],"has_params":true,"tags":[{"type":"module","string":""},{"type":"param","types":["String"],"name":"obj","description":"The string to convert into tokens"},{"type":"returns","string":"{Array}"}],"module":true,"related":{"href":""},"has_related":true,"methods":[]},{"id":"10-1397415736689","name":"Pipeline","signiture":"lunr.Pipeline()","type":"method","ctx":{"type":"method","receiver":"lunr","name":"Pipeline","string":"lunr.Pipeline()"},"description":{"full":"<p>lunr.Pipelines maintain an ordered list of functions to be applied to all<br />tokens in documents entering the search index and queries being ran against<br />the index.</p>\n\n<p>An instance of lunr.Index created with the lunr shortcut will contain a<br />pipeline with a stop word filter and an English language stemmer. Extra<br />functions can be added before or after either of these functions or these<br />default functions can be removed.</p>\n\n<p>When run the pipeline will call each function in turn, passing a token, the<br />index of that token in the original list of all tokens and finally a list of<br />all the original tokens.</p>\n\n<p>The output of functions in the pipeline will be passed to the next function<br />in the pipeline. To exclude a token from entering the index the function<br />should return undefined, the rest of the pipeline will not be called with<br />this token.</p>\n\n<p>For serialisation of pipelines to work, all functions used in an instance of<br />a pipeline should be registered with lunr.Pipeline. Registered functions can<br />then be loaded. If trying to load a serialised pipeline that uses functions<br />that are not registered an error will be thrown.</p>\n\n<p>If not planning on serialising the pipeline then registering pipeline functions<br />is not necessary.</p>","summary":"<p>lunr.Pipelines maintain an ordered list of functions to be applied to all<br />tokens in documents entering the search index and queries being ran against<br />the index.</p>","body":"<p>An instance of lunr.Index created with the lunr shortcut will contain a<br />pipeline with a stop word filter and an English language stemmer. Extra<br />functions can be added before or after either of these functions or these<br />default functions can be removed.</p>\n\n<p>When run the pipeline will call each function in turn, passing a token, the<br />index of that token in the original list of all tokens and finally a list of<br />all the original tokens.</p>\n\n<p>The output of functions in the pipeline will be passed to the next function<br />in the pipeline. To exclude a token from entering the index the function<br />should return undefined, the rest of the pipeline will not be called with<br />this token.</p>\n\n<p>For serialisation of pipelines to work, all functions used in an instance of<br />a pipeline should be registered with lunr.Pipeline. Registered functions can<br />then be loaded. If trying to load a serialised pipeline that uses functions<br />that are not registered an error will be thrown.</p>\n\n<p>If not planning on serialising the pipeline then registering pipeline functions<br />is not necessary.</p>"},"full_description":"<p>lunr.Pipelines maintain an ordered list of functions to be applied to all tokens in documents entering the search index and queries being ran against the index.</p>\n\n<p>An instance of lunr.Index created with the lunr shortcut will contain a pipeline with a stop word filter and an English language stemmer. Extra functions can be added before or after either of these functions or these default functions can be removed.</p>\n\n<p>When run the pipeline will call each function in turn, passing a token, the index of that token in the original list of all tokens and finally a list of all the original tokens.</p>\n\n<p>The output of functions in the pipeline will be passed to the next function in the pipeline. To exclude a token from entering the index the function should return undefined, the rest of the pipeline will not be called with this token.</p>\n\n<p>For serialisation of pipelines to work, all functions used in an instance of a pipeline should be registered with lunr.Pipeline. Registered functions can then be loaded. If trying to load a serialised pipeline that uses functions that are not registered an error will be thrown.</p>\n\n<p>If not planning on serialising the pipeline then registering pipeline functions is not necessary.</p>","code":"lunr.Pipeline = function () {\n  this._stack = []\n}\n\nlunr.Pipeline.registeredFunctions = {}","params":[],"has_params":false,"tags":[{"type":"constructor","string":""}],"module":true,"related":{"href":""},"has_related":true,"methods":[{"id":"11-1397415736689","name":"registerFunction","signiture":"lunr.Pipeline.registerFunction()","type":"method","ctx":{"type":"method","receiver":"lunr.Pipeline","name":"registerFunction","string":"lunr.Pipeline.registerFunction()"},"description":{"full":"<p>Register a function with the pipeline.</p>\n\n<p>Functions that are used in the pipeline should be registered if the pipeline<br />needs to be serialised, or a serialised pipeline needs to be loaded.</p>\n\n<p>Registering a function does not add it to a pipeline, functions must still be<br />added to instances of the pipeline for them to be used when running a pipeline.</p>","summary":"<p>Register a function with the pipeline.</p>","body":"<p>Functions that are used in the pipeline should be registered if the pipeline<br />needs to be serialised, or a serialised pipeline needs to be loaded.</p>\n\n<p>Registering a function does not add it to a pipeline, functions must still be<br />added to instances of the pipeline for them to be used when running a pipeline.</p>"},"full_description":"<p>Register a function with the pipeline.</p>\n\n<p>Functions that are used in the pipeline should be registered if the pipeline needs to be serialised, or a serialised pipeline needs to be loaded.</p>\n\n<p>Registering a function does not add it to a pipeline, functions must still be added to instances of the pipeline for them to be used when running a pipeline.</p>","code":"lunr.Pipeline.registerFunction = function (fn, label) {\n  if (label in this.registeredFunctions) {\n    lunr.utils.warn('Overwriting existing registered function: ' + label)\n  }\n\n  fn.label = label\n  lunr.Pipeline.registeredFunctions[fn.label] = fn\n}","params":[{"type":"param","types":["Function"],"name":"fn","description":"The function to check for."},{"type":"param","types":["String"],"name":"label","description":"The label to register this function with"}],"has_params":true,"tags":[{"type":"param","types":["Function"],"name":"fn","description":"The function to check for."},{"type":"param","types":["String"],"name":"label","description":"The label to register this function with"},{"type":"memberOf","parent":"Pipeline"}],"module":false,"parent":"Pipeline","related":{"href":""},"has_related":true},{"id":"12-1397415736689","name":"warnIfFunctionNotRegistered","signiture":"lunr.Pipeline.warnIfFunctionNotRegistered()","type":"method","ctx":{"type":"method","receiver":"lunr.Pipeline","name":"warnIfFunctionNotRegistered","string":"lunr.Pipeline.warnIfFunctionNotRegistered()"},"description":{"full":"<p>Warns if the function is not registered as a Pipeline function.</p>","summary":"<p>Warns if the function is not registered as a Pipeline function.</p>","body":""},"full_description":"<p>Warns if the function is not registered as a Pipeline function.</p>","code":"lunr.Pipeline.warnIfFunctionNotRegistered = function (fn) {\n  var isRegistered = fn.label && (fn.label in this.registeredFunctions)\n\n  if (!isRegistered) {\n    lunr.utils.warn('Function is not registered with pipeline. This may cause problems when serialising the index.\\n', fn)\n  }\n}","params":[{"type":"param","types":["Function"],"name":"fn","description":"The function to check for."}],"has_params":true,"tags":[{"type":"param","types":["Function"],"name":"fn","description":"The function to check for."},{"type":"private","string":""},{"type":"memberOf","parent":"Pipeline"}],"module":false,"parent":"Pipeline","related":{"href":""},"has_related":true},{"id":"13-1397415736690","name":"load","signiture":"lunr.Pipeline.load()","type":"method","ctx":{"type":"method","receiver":"lunr.Pipeline","name":"load","string":"lunr.Pipeline.load()"},"description":{"full":"<p>Loads a previously serialised pipeline.</p>\n\n<p>All functions to be loaded must already be registered with lunr.Pipeline.<br />If any function from the serialised data has not been registered then an<br />error will be thrown.</p>","summary":"<p>Loads a previously serialised pipeline.</p>","body":"<p>All functions to be loaded must already be registered with lunr.Pipeline.<br />If any function from the serialised data has not been registered then an<br />error will be thrown.</p>"},"full_description":"<p>Loads a previously serialised pipeline.</p>\n\n<p>All functions to be loaded must already be registered with lunr.Pipeline. If any function from the serialised data has not been registered then an error will be thrown.</p>","code":"lunr.Pipeline.load = function (serialised) {\n  var pipeline = new lunr.Pipeline\n\n  serialised.forEach(function (fnName) {\n    var fn = lunr.Pipeline.registeredFunctions[fnName]\n\n    if (fn) {\n      pipeline.add(fn)\n    } else {\n      throw new Error ('Cannot load un-registered function: ' + fnName)\n    }\n  })\n\n  return pipeline\n}","params":[{"type":"param","types":["Object"],"name":"serialised","description":"The serialised pipeline to load."}],"has_params":true,"tags":[{"type":"param","types":["Object"],"name":"serialised","description":"The serialised pipeline to load."},{"type":"returns","string":"{lunr.Pipeline}"},{"type":"memberOf","parent":"Pipeline"}],"module":false,"parent":"Pipeline","related":{"href":""},"has_related":true},{"id":"14-1397415736690","name":"add","signiture":"lunr.Pipeline.prototype.add()","type":"method","ctx":{"type":"method","receiver":"lunr.Pipeline.prototype","name":"add","string":"lunr.Pipeline.prototype.add()"},"description":{"full":"<p>Adds new functions to the end of the pipeline.</p>\n\n<p>Logs a warning if the function has not been registered.</p>","summary":"<p>Adds new functions to the end of the pipeline.</p>","body":"<p>Logs a warning if the function has not been registered.</p>"},"full_description":"<p>Adds new functions to the end of the pipeline.</p>\n\n<p>Logs a warning if the function has not been registered.</p>","code":"lunr.Pipeline.prototype.add = function () {\n  var fns = Array.prototype.slice.call(arguments)\n\n  fns.forEach(function (fn) {\n    lunr.Pipeline.warnIfFunctionNotRegistered(fn)\n    this._stack.push(fn)\n  }, this)\n}","params":[{"type":"param","types":["Function"],"name":"functions","description":"Any number of functions to add to the pipeline."}],"has_params":true,"tags":[{"type":"param","types":["Function"],"name":"functions","description":"Any number of functions to add to the pipeline."},{"type":"memberOf","parent":"Pipeline"}],"module":false,"parent":"Pipeline","related":{"href":""},"has_related":true},{"id":"15-1397415736690","name":"after","signiture":"lunr.Pipeline.prototype.after()","type":"method","ctx":{"type":"method","receiver":"lunr.Pipeline.prototype","name":"after","string":"lunr.Pipeline.prototype.after()"},"description":{"full":"<p>Adds a single function after a function that already exists in the<br />pipeline.</p>\n\n<p>Logs a warning if the function has not been registered.</p>","summary":"<p>Adds a single function after a function that already exists in the<br />pipeline.</p>","body":"<p>Logs a warning if the function has not been registered.</p>"},"full_description":"<p>Adds a single function after a function that already exists in the pipeline.</p>\n\n<p>Logs a warning if the function has not been registered.</p>","code":"lunr.Pipeline.prototype.after = function (existingFn, newFn) {\n  lunr.Pipeline.warnIfFunctionNotRegistered(newFn)\n\n  var pos = this._stack.indexOf(existingFn) + 1\n  this._stack.splice(pos, 0, newFn)\n}","params":[{"type":"param","types":["Function"],"name":"existingFn","description":"A function that already exists in the pipeline."},{"type":"param","types":["Function"],"name":"newFn","description":"The new function to add to the pipeline."}],"has_params":true,"tags":[{"type":"param","types":["Function"],"name":"existingFn","description":"A function that already exists in the pipeline."},{"type":"param","types":["Function"],"name":"newFn","description":"The new function to add to the pipeline."},{"type":"memberOf","parent":"Pipeline"}],"module":false,"parent":"Pipeline","related":{"href":""},"has_related":true},{"id":"16-1397415736690","name":"before","signiture":"lunr.Pipeline.prototype.before()","type":"method","ctx":{"type":"method","receiver":"lunr.Pipeline.prototype","name":"before","string":"lunr.Pipeline.prototype.before()"},"description":{"full":"<p>Adds a single function before a function that already exists in the<br />pipeline.</p>\n\n<p>Logs a warning if the function has not been registered.</p>","summary":"<p>Adds a single function before a function that already exists in the<br />pipeline.</p>","body":"<p>Logs a warning if the function has not been registered.</p>"},"full_description":"<p>Adds a single function before a function that already exists in the pipeline.</p>\n\n<p>Logs a warning if the function has not been registered.</p>","code":"lunr.Pipeline.prototype.before = function (existingFn, newFn) {\n  lunr.Pipeline.warnIfFunctionNotRegistered(newFn)\n\n  var pos = this._stack.indexOf(existingFn)\n  this._stack.splice(pos, 0, newFn)\n}","params":[{"type":"param","types":["Function"],"name":"existingFn","description":"A function that already exists in the pipeline."},{"type":"param","types":["Function"],"name":"newFn","description":"The new function to add to the pipeline."}],"has_params":true,"tags":[{"type":"param","types":["Function"],"name":"existingFn","description":"A function that already exists in the pipeline."},{"type":"param","types":["Function"],"name":"newFn","description":"The new function to add to the pipeline."},{"type":"memberOf","parent":"Pipeline"}],"module":false,"parent":"Pipeline","related":{"href":""},"has_related":true},{"id":"17-1397415736690","name":"remove","signiture":"lunr.Pipeline.prototype.remove()","type":"method","ctx":{"type":"method","receiver":"lunr.Pipeline.prototype","name":"remove","string":"lunr.Pipeline.prototype.remove()"},"description":{"full":"<p>Removes a function from the pipeline.</p>","summary":"<p>Removes a function from the pipeline.</p>","body":""},"full_description":"<p>Removes a function from the pipeline.</p>","code":"lunr.Pipeline.prototype.remove = function (fn) {\n  var pos = this._stack.indexOf(fn)\n  this._stack.splice(pos, 1)\n}","params":[{"type":"param","types":["Function"],"name":"fn","description":"The function to remove from the pipeline."}],"has_params":true,"tags":[{"type":"param","types":["Function"],"name":"fn","description":"The function to remove from the pipeline."},{"type":"memberOf","parent":"Pipeline"}],"module":false,"parent":"Pipeline","related":{"href":""},"has_related":true},{"id":"18-1397415736690","name":"run","signiture":"lunr.Pipeline.prototype.run()","type":"method","ctx":{"type":"method","receiver":"lunr.Pipeline.prototype","name":"run","string":"lunr.Pipeline.prototype.run()"},"description":{"full":"<p>Runs the current list of functions that make up the pipeline against the<br />passed tokens.</p>","summary":"<p>Runs the current list of functions that make up the pipeline against the<br />passed tokens.</p>","body":""},"full_description":"<p>Runs the current list of functions that make up the pipeline against the passed tokens.</p>","code":"lunr.Pipeline.prototype.run = function (tokens) {\n  var out = [],\n      tokenLength = tokens.length,\n      stackLength = this._stack.length\n\n  for (var i = 0; i < tokenLength; i++) {\n    var token = tokens[i]\n\n    for (var j = 0; j < stackLength; j++) {\n      token = this._stack[j](token, i, tokens)\n      if (token === void 0) break\n    };\n\n    if (token !== void 0) out.push(token)\n  };\n\n  return out\n}","params":[{"type":"param","types":["Array"],"name":"tokens","description":"The tokens to run through the pipeline."}],"has_params":true,"tags":[{"type":"param","types":["Array"],"name":"tokens","description":"The tokens to run through the pipeline."},{"type":"returns","string":"{Array}"},{"type":"memberOf","parent":"Pipeline"}],"module":false,"parent":"Pipeline","related":{"href":""},"has_related":true},{"id":"19-1397415736690","name":"reset","signiture":"lunr.Pipeline.prototype.reset()","type":"method","ctx":{"type":"method","receiver":"lunr.Pipeline.prototype","name":"reset","string":"lunr.Pipeline.prototype.reset()"},"description":{"full":"<p>Resets the pipeline by removing any existing processors.</p>","summary":"<p>Resets the pipeline by removing any existing processors.</p>","body":""},"full_description":"<p>Resets the pipeline by removing any existing processors.</p>","code":"lunr.Pipeline.prototype.reset = function () {\n  this._stack = []\n}","params":[],"has_params":false,"tags":[{"type":"memberOf","parent":"Pipeline"}],"module":false,"parent":"Pipeline","related":{"href":""},"has_related":true},{"id":"20-1397415736690","name":"toJSON","signiture":"lunr.Pipeline.prototype.toJSON()","type":"method","ctx":{"type":"method","receiver":"lunr.Pipeline.prototype","name":"toJSON","string":"lunr.Pipeline.prototype.toJSON()"},"description":{"full":"<p>Returns a representation of the pipeline ready for serialisation.</p>\n\n<p>Logs a warning if the function has not been registered.</p>","summary":"<p>Returns a representation of the pipeline ready for serialisation.</p>","body":"<p>Logs a warning if the function has not been registered.</p>"},"full_description":"<p>Returns a representation of the pipeline ready for serialisation.</p>\n\n<p>Logs a warning if the function has not been registered.</p>","code":"lunr.Pipeline.prototype.toJSON = function () {\n  return this._stack.map(function (fn) {\n    lunr.Pipeline.warnIfFunctionNotRegistered(fn)\n\n    return fn.label\n  })\n}","params":[],"has_params":false,"tags":[{"type":"returns","string":"{Array}"},{"type":"memberOf","parent":"Pipeline"}],"module":false,"parent":"Pipeline","related":{"href":""},"has_related":true}]},{"id":"21-1397415736690","name":"Vector","signiture":"lunr.Vector()","type":"method","ctx":{"type":"method","receiver":"lunr","name":"Vector","string":"lunr.Vector()"},"description":{"full":"<p>lunr.Vectors implement vector related operations for<br />a series of elements.</p>","summary":"<p>lunr.Vectors implement vector related operations for<br />a series of elements.</p>","body":""},"full_description":"<p>lunr.Vectors implement vector related operations for a series of elements.</p>","code":"lunr.Vector = function () {\n  this._magnitude = null\n  this.list = undefined\n  this.length = 0\n}","params":[],"has_params":false,"tags":[{"type":"constructor","string":""}],"module":true,"related":{"href":""},"has_related":true,"methods":[{"id":"22-1397415736690","name":"Node","signiture":"lunr.Vector.Node()","type":"method","ctx":{"type":"method","receiver":"lunr.Vector","name":"Node","string":"lunr.Vector.Node()"},"description":{"full":"<p>lunr.Vector.Node is a simple struct for each node<br />in a lunr.Vector.</p>","summary":"<p>lunr.Vector.Node is a simple struct for each node<br />in a lunr.Vector.</p>","body":""},"full_description":"<p>lunr.Vector.Node is a simple struct for each node in a lunr.Vector.</p>","code":"lunr.Vector.Node = function (idx, val, next) {\n  this.idx = idx\n  this.val = val\n  this.next = next\n}","params":[{"type":"param","types":["Number"],"name":"The","description":"index of the node in the vector."},{"type":"param","types":["Object"],"name":"The","description":"data at this node in the vector."},{"type":"param","types":["lunr.Vector.Node"],"name":"The","description":"node directly after this node in the vector."}],"has_params":true,"tags":[{"type":"private","string":""},{"type":"param","types":["Number"],"name":"The","description":"index of the node in the vector."},{"type":"param","types":["Object"],"name":"The","description":"data at this node in the vector."},{"type":"param","types":["lunr.Vector.Node"],"name":"The","description":"node directly after this node in the vector."},{"type":"constructor","string":""},{"type":"memberOf","parent":"Vector"}],"module":true,"parent":"Vector","related":{"href":""},"has_related":true,"methods":[]},{"id":"24-1397415736690","name":"magnitude","signiture":"lunr.Vector.prototype.magnitude()","type":"method","ctx":{"type":"method","receiver":"lunr.Vector.prototype","name":"magnitude","string":"lunr.Vector.prototype.magnitude()"},"description":{"full":"<p>Calculates the magnitude of this vector.</p>","summary":"<p>Calculates the magnitude of this vector.</p>","body":""},"full_description":"<p>Calculates the magnitude of this vector.</p>","code":"lunr.Vector.prototype.magnitude = function () {\n  if (this._magniture) return this._magnitude\n  var node = this.list,\n      sumOfSquares = 0,\n      val\n\n  while (node) {\n    val = node.val\n    sumOfSquares += val * val\n    node = node.next\n  }\n\n  return this._magnitude = Math.sqrt(sumOfSquares)\n}","params":[],"has_params":false,"tags":[{"type":"returns","string":"{Number}"},{"type":"memberOf","parent":"Vector"}],"module":false,"parent":"Vector","related":{"href":""},"has_related":true},{"id":"25-1397415736690","name":"dot","signiture":"lunr.Vector.prototype.dot()","type":"method","ctx":{"type":"method","receiver":"lunr.Vector.prototype","name":"dot","string":"lunr.Vector.prototype.dot()"},"description":{"full":"<p>Calculates the dot product of this vector and another vector.</p>","summary":"<p>Calculates the dot product of this vector and another vector.</p>","body":""},"full_description":"<p>Calculates the dot product of this vector and another vector.</p>","code":"lunr.Vector.prototype.dot = function (otherVector) {\n  var node = this.list,\n      otherNode = otherVector.list,\n      dotProduct = 0\n\n  while (node && otherNode) {\n    if (node.idx < otherNode.idx) {\n      node = node.next\n    } else if (node.idx > otherNode.idx) {\n      otherNode = otherNode.next\n    } else {\n      dotProduct += node.val * otherNode.val\n      node = node.next\n      otherNode = otherNode.next\n    }\n  }\n\n  return dotProduct\n}","params":[{"type":"param","types":["lunr.Vector"],"name":"otherVector","description":"The vector to compute the dot product with."}],"has_params":true,"tags":[{"type":"param","types":["lunr.Vector"],"name":"otherVector","description":"The vector to compute the dot product with."},{"type":"returns","string":"{Number}"},{"type":"memberOf","parent":"Vector"}],"module":false,"parent":"Vector","related":{"href":""},"has_related":true},{"id":"26-1397415736690","name":"similarity","signiture":"lunr.Vector.prototype.similarity()","type":"method","ctx":{"type":"method","receiver":"lunr.Vector.prototype","name":"similarity","string":"lunr.Vector.prototype.similarity()"},"description":{"full":"<p>Calculates the cosine similarity between this vector and another<br />vector.</p>","summary":"<p>Calculates the cosine similarity between this vector and another<br />vector.</p>","body":""},"full_description":"<p>Calculates the cosine similarity between this vector and another vector.</p>","code":"lunr.Vector.prototype.similarity = function (otherVector) {\n  return this.dot(otherVector) / (this.magnitude() * otherVector.magnitude())\n}","params":[{"type":"param","types":["lunr.Vector"],"name":"otherVector","description":"The other vector to calculate the"}],"has_params":true,"tags":[{"type":"param","types":["lunr.Vector"],"name":"otherVector","description":"The other vector to calculate the"},{"type":"similarity","string":"with."},{"type":"returns","string":"{Number}"},{"type":"memberOf","parent":"Vector"}],"module":false,"parent":"Vector","related":{"href":""},"has_related":true}]},{"id":"22-1397415736690","name":"Node","signiture":"lunr.Vector.Node()","type":"method","ctx":{"type":"method","receiver":"lunr.Vector","name":"Node","string":"lunr.Vector.Node()"},"description":{"full":"<p>lunr.Vector.Node is a simple struct for each node<br />in a lunr.Vector.</p>","summary":"<p>lunr.Vector.Node is a simple struct for each node<br />in a lunr.Vector.</p>","body":""},"full_description":"<p>lunr.Vector.Node is a simple struct for each node in a lunr.Vector.</p>","code":"lunr.Vector.Node = function (idx, val, next) {\n  this.idx = idx\n  this.val = val\n  this.next = next\n}","params":[{"type":"param","types":["Number"],"name":"The","description":"index of the node in the vector."},{"type":"param","types":["Object"],"name":"The","description":"data at this node in the vector."},{"type":"param","types":["lunr.Vector.Node"],"name":"The","description":"node directly after this node in the vector."}],"has_params":true,"tags":[{"type":"private","string":""},{"type":"param","types":["Number"],"name":"The","description":"index of the node in the vector."},{"type":"param","types":["Object"],"name":"The","description":"data at this node in the vector."},{"type":"param","types":["lunr.Vector.Node"],"name":"The","description":"node directly after this node in the vector."},{"type":"constructor","string":""},{"type":"memberOf","parent":"Vector"}],"module":true,"parent":"Vector","related":{"href":""},"has_related":true,"methods":[]},{"id":"27-1397415736690","name":"SortedSet","signiture":"lunr.SortedSet()","type":"method","ctx":{"type":"method","receiver":"lunr","name":"SortedSet","string":"lunr.SortedSet()"},"description":{"full":"<p>lunr.SortedSets are used to maintain an array of uniq values in a sorted<br />order.</p>","summary":"<p>lunr.SortedSets are used to maintain an array of uniq values in a sorted<br />order.</p>","body":""},"full_description":"<p>lunr.SortedSets are used to maintain an array of uniq values in a sorted order.</p>","code":"lunr.SortedSet = function () {\n  this.length = 0\n  this.elements = []\n}","params":[],"has_params":false,"tags":[{"type":"constructor","string":""}],"module":true,"related":{"href":""},"has_related":true,"methods":[{"id":"28-1397415736690","name":"load","signiture":"lunr.SortedSet.load()","type":"method","ctx":{"type":"method","receiver":"lunr.SortedSet","name":"load","string":"lunr.SortedSet.load()"},"description":{"full":"<p>Loads a previously serialised sorted set.</p>","summary":"<p>Loads a previously serialised sorted set.</p>","body":""},"full_description":"<p>Loads a previously serialised sorted set.</p>","code":"lunr.SortedSet.load = function (serialisedData) {\n  var set = new this\n\n  set.elements = serialisedData\n  set.length = serialisedData.length\n\n  return set\n}","params":[{"type":"param","types":["Array"],"name":"serialisedData","description":"The serialised set to load."}],"has_params":true,"tags":[{"type":"param","types":["Array"],"name":"serialisedData","description":"The serialised set to load."},{"type":"returns","string":"{lunr.SortedSet}"},{"type":"memberOf","parent":"SortedSet"}],"module":false,"parent":"SortedSet","related":{"href":""},"has_related":true},{"id":"29-1397415736690","name":"add","signiture":"lunr.SortedSet.prototype.add()","type":"method","ctx":{"type":"method","receiver":"lunr.SortedSet.prototype","name":"add","string":"lunr.SortedSet.prototype.add()"},"description":{"full":"<p>Inserts new items into the set in the correct position to maintain the<br />order.</p>","summary":"<p>Inserts new items into the set in the correct position to maintain the<br />order.</p>","body":""},"full_description":"<p>Inserts new items into the set in the correct position to maintain the order.</p>","code":"lunr.SortedSet.prototype.add = function () {\n  Array.prototype.slice.call(arguments).forEach(function (element) {\n    if (~this.indexOf(element)) return\n    this.elements.splice(this.locationFor(element), 0, element)\n  }, this)\n\n  this.length = this.elements.length\n}","params":[{"type":"param","types":["Object"],"name":"The","description":"objects to add to this set."}],"has_params":true,"tags":[{"type":"param","types":["Object"],"name":"The","description":"objects to add to this set."},{"type":"memberOf","parent":"SortedSet"}],"module":false,"parent":"SortedSet","related":{"href":""},"has_related":true},{"id":"30-1397415736690","name":"toArray","signiture":"lunr.SortedSet.prototype.toArray()","type":"method","ctx":{"type":"method","receiver":"lunr.SortedSet.prototype","name":"toArray","string":"lunr.SortedSet.prototype.toArray()"},"description":{"full":"<p>Converts this sorted set into an array.</p>","summary":"<p>Converts this sorted set into an array.</p>","body":""},"full_description":"<p>Converts this sorted set into an array.</p>","code":"lunr.SortedSet.prototype.toArray = function () {\n  return this.elements.slice()\n}","params":[],"has_params":false,"tags":[{"type":"returns","string":"{Array}"},{"type":"memberOf","parent":"SortedSet"}],"module":false,"parent":"SortedSet","related":{"href":""},"has_related":true},{"id":"31-1397415736690","name":"map","signiture":"lunr.SortedSet.prototype.map()","type":"method","ctx":{"type":"method","receiver":"lunr.SortedSet.prototype","name":"map","string":"lunr.SortedSet.prototype.map()"},"description":{"full":"<p>Creates a new array with the results of calling a provided function on every<br />element in this sorted set.</p>\n\n<p>Delegates to Array.prototype.map and has the same signature.</p>","summary":"<p>Creates a new array with the results of calling a provided function on every<br />element in this sorted set.</p>","body":"<p>Delegates to Array.prototype.map and has the same signature.</p>"},"full_description":"<p>Creates a new array with the results of calling a provided function on every element in this sorted set.</p>\n\n<p>Delegates to Array.prototype.map and has the same signature.</p>","code":"lunr.SortedSet.prototype.map = function (fn, ctx) {\n  return this.elements.map(fn, ctx)\n}","params":[{"type":"param","types":["Function"],"name":"fn","description":"The function that is called on each element of the"},{"type":"param","types":["Object"],"name":"ctx","description":"An optional object that can be used as the context"}],"has_params":true,"tags":[{"type":"param","types":["Function"],"name":"fn","description":"The function that is called on each element of the"},{"type":"set.","string":""},{"type":"param","types":["Object"],"name":"ctx","description":"An optional object that can be used as the context"},{"type":"for","string":"the function fn."},{"type":"returns","string":"{Array}"},{"type":"memberOf","parent":"SortedSet"}],"module":false,"parent":"SortedSet","related":{"href":""},"has_related":true},{"id":"32-1397415736690","name":"forEach","signiture":"lunr.SortedSet.prototype.forEach()","type":"method","ctx":{"type":"method","receiver":"lunr.SortedSet.prototype","name":"forEach","string":"lunr.SortedSet.prototype.forEach()"},"description":{"full":"<p>Executes a provided function once per sorted set element.</p>\n\n<p>Delegates to Array.prototype.forEach and has the same signature.</p>","summary":"<p>Executes a provided function once per sorted set element.</p>","body":"<p>Delegates to Array.prototype.forEach and has the same signature.</p>"},"full_description":"<p>Executes a provided function once per sorted set element.</p>\n\n<p>Delegates to Array.prototype.forEach and has the same signature.</p>","code":"lunr.SortedSet.prototype.forEach = function (fn, ctx) {\n  return this.elements.forEach(fn, ctx)\n}","params":[{"type":"param","types":["Function"],"name":"fn","description":"The function that is called on each element of the"},{"type":"param","types":["Object"],"name":"ctx","description":"An optional object that can be used as the context"}],"has_params":true,"tags":[{"type":"param","types":["Function"],"name":"fn","description":"The function that is called on each element of the"},{"type":"set.","string":""},{"type":"param","types":["Object"],"name":"ctx","description":"An optional object that can be used as the context"},{"type":"memberOf","parent":"SortedSet"},{"type":"for","string":"the function fn."}],"module":false,"parent":"SortedSet","related":{"href":""},"has_related":true},{"id":"33-1397415736690","name":"indexOf","signiture":"lunr.SortedSet.prototype.indexOf()","type":"method","ctx":{"type":"method","receiver":"lunr.SortedSet.prototype","name":"indexOf","string":"lunr.SortedSet.prototype.indexOf()"},"description":{"full":"<p>Returns the index at which a given element can be found in the<br />sorted set, or -1 if it is not present.</p>","summary":"<p>Returns the index at which a given element can be found in the<br />sorted set, or -1 if it is not present.</p>","body":""},"full_description":"<p>Returns the index at which a given element can be found in the sorted set, or -1 if it is not present.</p>","code":"lunr.SortedSet.prototype.indexOf = function (elem, start, end) {\n  var start = start || 0,\n      end = end || this.elements.length,\n      sectionLength = end - start,\n      pivot = start + Math.floor(sectionLength / 2),\n      pivotElem = this.elements[pivot]\n\n  if (sectionLength <= 1) {\n    if (pivotElem === elem) {\n      return pivot\n    } else {\n      return -1\n    }\n  }\n\n  if (pivotElem < elem) return this.indexOf(elem, pivot, end)\n  if (pivotElem > elem) return this.indexOf(elem, start, pivot)\n  if (pivotElem === elem) return pivot\n}","params":[{"type":"param","types":["Object"],"name":"elem","description":"The object to locate in the sorted set."},{"type":"param","types":["Number"],"name":"start","description":"An optional index at which to start searching from"},{"type":"param","types":["Number"],"name":"end","description":"An optional index at which to stop search from within"}],"has_params":true,"tags":[{"type":"param","types":["Object"],"name":"elem","description":"The object to locate in the sorted set."},{"type":"param","types":["Number"],"name":"start","description":"An optional index at which to start searching from"},{"type":"within","string":"the set."},{"type":"param","types":["Number"],"name":"end","description":"An optional index at which to stop search from within"},{"type":"the","string":"set."},{"type":"returns","string":"{Number}"},{"type":"memberOf","parent":"SortedSet"}],"module":false,"parent":"SortedSet","related":{"href":""},"has_related":true},{"id":"34-1397415736690","name":"locationFor","signiture":"lunr.SortedSet.prototype.locationFor()","type":"method","ctx":{"type":"method","receiver":"lunr.SortedSet.prototype","name":"locationFor","string":"lunr.SortedSet.prototype.locationFor()"},"description":{"full":"<p>Returns the position within the sorted set that an element should be<br />inserted at to maintain the current order of the set.</p>\n\n<p>This function assumes that the element to search for does not already exist<br />in the sorted set.</p>","summary":"<p>Returns the position within the sorted set that an element should be<br />inserted at to maintain the current order of the set.</p>","body":"<p>This function assumes that the element to search for does not already exist<br />in the sorted set.</p>"},"full_description":"<p>Returns the position within the sorted set that an element should be inserted at to maintain the current order of the set.</p>\n\n<p>This function assumes that the element to search for does not already exist in the sorted set.</p>","code":"lunr.SortedSet.prototype.locationFor = function (elem, start, end) {\n  var start = start || 0,\n      end = end || this.elements.length,\n      sectionLength = end - start,\n      pivot = start + Math.floor(sectionLength / 2),\n      pivotElem = this.elements[pivot]\n\n  if (sectionLength <= 1) {\n    if (pivotElem > elem) return pivot\n    if (pivotElem < elem) return pivot + 1\n  }\n\n  if (pivotElem < elem) return this.locationFor(elem, pivot, end)\n  if (pivotElem > elem) return this.locationFor(elem, start, pivot)\n}","params":[{"type":"param","types":["Object"],"name":"elem","description":"The elem to find the position for in the set"},{"type":"param","types":["Number"],"name":"start","description":"An optional index at which to start searching from"},{"type":"param","types":["Number"],"name":"end","description":"An optional index at which to stop search from within"}],"has_params":true,"tags":[{"type":"param","types":["Object"],"name":"elem","description":"The elem to find the position for in the set"},{"type":"param","types":["Number"],"name":"start","description":"An optional index at which to start searching from"},{"type":"within","string":"the set."},{"type":"param","types":["Number"],"name":"end","description":"An optional index at which to stop search from within"},{"type":"the","string":"set."},{"type":"returns","string":"{Number}"},{"type":"memberOf","parent":"SortedSet"}],"module":false,"parent":"SortedSet","related":{"href":""},"has_related":true},{"id":"35-1397415736690","name":"intersect","signiture":"lunr.SortedSet.prototype.intersect()","type":"method","ctx":{"type":"method","receiver":"lunr.SortedSet.prototype","name":"intersect","string":"lunr.SortedSet.prototype.intersect()"},"description":{"full":"<p>Creates a new lunr.SortedSet that contains the elements in the intersection<br />of this set and the passed set.</p>","summary":"<p>Creates a new lunr.SortedSet that contains the elements in the intersection<br />of this set and the passed set.</p>","body":""},"full_description":"<p>Creates a new lunr.SortedSet that contains the elements in the intersection of this set and the passed set.</p>","code":"lunr.SortedSet.prototype.intersect = function (otherSet) {\n  var intersectSet = new lunr.SortedSet,\n      i = 0, j = 0,\n      a_len = this.length, b_len = otherSet.length,\n      a = this.elements, b = otherSet.elements\n\n  while (true) {\n    if (i > a_len - 1 || j > b_len - 1) break\n\n    if (a[i] === b[j]) {\n      intersectSet.add(a[i])\n      i++, j++\n      continue\n    }\n\n    if (a[i] < b[j]) {\n      i++\n      continue\n    }\n\n    if (a[i] > b[j]) {\n      j++\n      continue\n    }\n  };\n\n  return intersectSet\n}","params":[{"type":"param","types":["lunr.SortedSet"],"name":"otherSet","description":"The set to intersect with this set."}],"has_params":true,"tags":[{"type":"param","types":["lunr.SortedSet"],"name":"otherSet","description":"The set to intersect with this set."},{"type":"returns","string":"{lunr.SortedSet}"},{"type":"memberOf","parent":"SortedSet"}],"module":false,"parent":"SortedSet","related":{"href":""},"has_related":true},{"id":"36-1397415736690","name":"clone","signiture":"lunr.SortedSet.prototype.clone()","type":"method","ctx":{"type":"method","receiver":"lunr.SortedSet.prototype","name":"clone","string":"lunr.SortedSet.prototype.clone()"},"description":{"full":"<p>Makes a copy of this set</p>","summary":"<p>Makes a copy of this set</p>","body":""},"full_description":"<p>Makes a copy of this set</p>","code":"lunr.SortedSet.prototype.clone = function () {\n  var clone = new lunr.SortedSet\n\n  clone.elements = this.toArray()\n  clone.length = clone.elements.length\n\n  return clone\n}","params":[],"has_params":false,"tags":[{"type":"returns","string":"{lunr.SortedSet}"},{"type":"memberOf","parent":"SortedSet"}],"module":false,"parent":"SortedSet","related":{"href":""},"has_related":true},{"id":"37-1397415736690","name":"union","signiture":"lunr.SortedSet.prototype.union()","type":"method","ctx":{"type":"method","receiver":"lunr.SortedSet.prototype","name":"union","string":"lunr.SortedSet.prototype.union()"},"description":{"full":"<p>Creates a new lunr.SortedSet that contains the elements in the union<br />of this set and the passed set.</p>","summary":"<p>Creates a new lunr.SortedSet that contains the elements in the union<br />of this set and the passed set.</p>","body":""},"full_description":"<p>Creates a new lunr.SortedSet that contains the elements in the union of this set and the passed set.</p>","code":"lunr.SortedSet.prototype.union = function (otherSet) {\n  var longSet, shortSet, unionSet\n\n  if (this.length >= otherSet.length) {\n    longSet = this, shortSet = otherSet\n  } else {\n    longSet = otherSet, shortSet = this\n  }\n\n  unionSet = longSet.clone()\n\n  unionSet.add.apply(unionSet, shortSet.toArray())\n\n  return unionSet\n}","params":[{"type":"param","types":["lunr.SortedSet"],"name":"otherSet","description":"The set to union with this set."}],"has_params":true,"tags":[{"type":"param","types":["lunr.SortedSet"],"name":"otherSet","description":"The set to union with this set."},{"type":"returns","string":"{lunr.SortedSet}"},{"type":"memberOf","parent":"SortedSet"}],"module":false,"parent":"SortedSet","related":{"href":""},"has_related":true},{"id":"38-1397415736690","name":"toJSON","signiture":"lunr.SortedSet.prototype.toJSON()","type":"method","ctx":{"type":"method","receiver":"lunr.SortedSet.prototype","name":"toJSON","string":"lunr.SortedSet.prototype.toJSON()"},"description":{"full":"<p>Returns a representation of the sorted set ready for serialisation.</p>","summary":"<p>Returns a representation of the sorted set ready for serialisation.</p>","body":""},"full_description":"<p>Returns a representation of the sorted set ready for serialisation.</p>","code":"lunr.SortedSet.prototype.toJSON = function () {\n  return this.toArray()\n}","params":[],"has_params":false,"tags":[{"type":"returns","string":"{Array}"},{"type":"memberOf","parent":"SortedSet"}],"module":false,"parent":"SortedSet","related":{"href":""},"has_related":true}]},{"id":"39-1397415736690","name":"Index","signiture":"lunr.Index()","type":"method","ctx":{"type":"method","receiver":"lunr","name":"Index","string":"lunr.Index()"},"description":{"full":"<p>lunr.Index is object that manages a search index.  It contains the indexes<br />and stores all the tokens and document lookups.  It also provides the main<br />user facing API for the library.</p>","summary":"<p>lunr.Index is object that manages a search index.  It contains the indexes<br />and stores all the tokens and document lookups.  It also provides the main<br />user facing API for the library.</p>","body":""},"full_description":"<p>lunr.Index is object that manages a search index.  It contains the indexes and stores all the tokens and document lookups.  It also provides the main user facing API for the library.</p>","code":"lunr.Index = function () {\n  this._fields = []\n  this._ref = 'id'\n  this.indexPipeline = new lunr.Pipeline\n  this.searchPipeline = new lunr.Pipeline\n  this.documentStore = new lunr.Store\n  this.tokenStore = new lunr.TokenStore\n  this.corpusTokens = new lunr.SortedSet\n  this.eventEmitter =  new lunr.EventEmitter\n\n  this._idfCache = {}\n\n  this.on('add', 'remove', 'update', (function () {\n    this._idfCache = {}\n  }).bind(this))\n}","params":[],"has_params":false,"tags":[{"type":"constructor","string":""}],"module":true,"related":{"href":""},"has_related":true,"methods":[{"id":"40-1397415736690","name":"on","signiture":"lunr.Index.prototype.on()","type":"method","ctx":{"type":"method","receiver":"lunr.Index.prototype","name":"on","string":"lunr.Index.prototype.on()"},"description":{"full":"<p>Bind a handler to events being emitted by the index.</p>\n\n<p>The handler can be bound to many events at the same time.</p>","summary":"<p>Bind a handler to events being emitted by the index.</p>","body":"<p>The handler can be bound to many events at the same time.</p>"},"full_description":"<p>Bind a handler to events being emitted by the index.</p>\n\n<p>The handler can be bound to many events at the same time.</p>","code":"lunr.Index.prototype.on = function () {\n  var args = Array.prototype.slice.call(arguments)\n  return this.eventEmitter.addListener.apply(this.eventEmitter, args)\n}","params":[{"type":"param","types":["String"],"name":"[eventName]","description":"The name(s) of events to bind the function to."},{"type":"param","types":["Function"],"name":"handler","description":"The serialised set to load."}],"has_params":true,"tags":[{"type":"param","types":["String"],"name":"[eventName]","description":"The name(s) of events to bind the function to."},{"type":"param","types":["Function"],"name":"handler","description":"The serialised set to load."},{"type":"memberOf","parent":"Index"}],"module":false,"parent":"Index","related":{"href":""},"has_related":true},{"id":"41-1397415736690","name":"off","signiture":"lunr.Index.prototype.off()","type":"method","ctx":{"type":"method","receiver":"lunr.Index.prototype","name":"off","string":"lunr.Index.prototype.off()"},"description":{"full":"<p>Removes a handler from an event being emitted by the index.</p>","summary":"<p>Removes a handler from an event being emitted by the index.</p>","body":""},"full_description":"<p>Removes a handler from an event being emitted by the index.</p>","code":"lunr.Index.prototype.off = function (name, fn) {\n  return this.eventEmitter.removeListener(name, fn)\n}","params":[{"type":"param","types":["String"],"name":"eventName","description":"The name of events to remove the function from."},{"type":"param","types":["Function"],"name":"handler","description":"The serialised set to load."}],"has_params":true,"tags":[{"type":"param","types":["String"],"name":"eventName","description":"The name of events to remove the function from."},{"type":"param","types":["Function"],"name":"handler","description":"The serialised set to load."},{"type":"memberOf","parent":"Index"}],"module":false,"parent":"Index","related":{"href":""},"has_related":true},{"id":"42-1397415736690","name":"load","signiture":"lunr.Index.load()","type":"method","ctx":{"type":"method","receiver":"lunr.Index","name":"load","string":"lunr.Index.load()"},"description":{"full":"<p>Loads a previously serialised index.</p>\n\n<p>Issues a warning if the index being imported was serialised<br />by a different version of lunr.</p>","summary":"<p>Loads a previously serialised index.</p>","body":"<p>Issues a warning if the index being imported was serialised<br />by a different version of lunr.</p>"},"full_description":"<p>Loads a previously serialised index.</p>\n\n<p>Issues a warning if the index being imported was serialised by a different version of lunr.</p>","code":"lunr.Index.load = function (serialisedData) {\n  if (serialisedData.version !== lunr.version) {\n    lunr.utils.warn('version mismatch: current ' + lunr.version + ' importing ' + serialisedData.version)\n  }\n\n  var idx = new this\n\n  idx._fields = serialisedData.fields\n  idx._ref = serialisedData.ref\n\n  idx.documentStore = lunr.Store.load(serialisedData.documentStore)\n  idx.tokenStore = lunr.TokenStore.load(serialisedData.tokenStore)\n  idx.corpusTokens = lunr.SortedSet.load(serialisedData.corpusTokens)\n  idx.indexPipeline = lunr.Pipeline.load(serialisedData.indexPipeline)\n  idx.searchPipeline = lunr.Pipeline.load(serialisedData.searchPipeline)\n\n  return idx\n}","params":[{"type":"param","types":["Object"],"name":"serialisedData","description":"The serialised set to load."}],"has_params":true,"tags":[{"type":"param","types":["Object"],"name":"serialisedData","description":"The serialised set to load."},{"type":"returns","string":"{lunr.Index}"},{"type":"memberOf","parent":"Index"}],"module":false,"parent":"Index","related":{"href":""},"has_related":true},{"id":"43-1397415736690","name":"field","signiture":"lunr.Index.prototype.field()","type":"method","ctx":{"type":"method","receiver":"lunr.Index.prototype","name":"field","string":"lunr.Index.prototype.field()"},"description":{"full":"<p>Adds a field to the list of fields that will be searchable within documents<br />in the index.</p>\n\n<p>An optional boost param can be passed to affect how much tokens in this field<br />rank in search results, by default the boost value is 1.</p>\n\n<p>Fields should be added before any documents are added to the index, fields<br />that are added after documents are added to the index will only apply to new<br />documents added to the index.</p>","summary":"<p>Adds a field to the list of fields that will be searchable within documents<br />in the index.</p>","body":"<p>An optional boost param can be passed to affect how much tokens in this field<br />rank in search results, by default the boost value is 1.</p>\n\n<p>Fields should be added before any documents are added to the index, fields<br />that are added after documents are added to the index will only apply to new<br />documents added to the index.</p>"},"full_description":"<p>Adds a field to the list of fields that will be searchable within documents in the index.</p>\n\n<p>An optional boost param can be passed to affect how much tokens in this field rank in search results, by default the boost value is 1.</p>\n\n<p>Fields should be added before any documents are added to the index, fields that are added after documents are added to the index will only apply to new documents added to the index.</p>","code":"lunr.Index.prototype.field = function (fieldName, opts) {\n  var opts = opts || {},\n      field = { name: fieldName, boost: opts.boost || 1 }\n\n  this._fields.push(field)\n  return this\n}","params":[{"type":"param","types":["String"],"name":"fieldName","description":"The name of the field within the document that"},{"type":"param","types":["Number"],"name":"boost","description":"An optional boost that can be applied to terms in this"}],"has_params":true,"tags":[{"type":"param","types":["String"],"name":"fieldName","description":"The name of the field within the document that"},{"type":"should","string":"be indexed"},{"type":"param","types":["Number"],"name":"boost","description":"An optional boost that can be applied to terms in this"},{"type":"field.","string":""},{"type":"returns","string":"{lunr.Index}"},{"type":"memberOf","parent":"Index"}],"module":false,"parent":"Index","related":{"href":""},"has_related":true},{"id":"44-1397415736690","name":"ref","signiture":"lunr.Index.prototype.ref()","type":"method","ctx":{"type":"method","receiver":"lunr.Index.prototype","name":"ref","string":"lunr.Index.prototype.ref()"},"description":{"full":"<p>Sets the property used to uniquely identify documents added to the index,<br />by default this property is 'id'.</p>\n\n<p>This should only be changed before adding documents to the index, changing<br />the ref property without resetting the index can lead to unexpected results.</p>","summary":"<p>Sets the property used to uniquely identify documents added to the index,<br />by default this property is 'id'.</p>","body":"<p>This should only be changed before adding documents to the index, changing<br />the ref property without resetting the index can lead to unexpected results.</p>"},"full_description":"<p>Sets the property used to uniquely identify documents added to the index, by default this property is 'id'.</p>\n\n<p>This should only be changed before adding documents to the index, changing the ref property without resetting the index can lead to unexpected results.</p>","code":"lunr.Index.prototype.ref = function (refName) {\n  this._ref = refName\n  return this\n}","params":[{"type":"param","types":["String"],"name":"refName","description":"The property to use to uniquely identify the"},{"type":"param","types":["Boolean"],"name":"emitEvent","description":"Whether to emit add events, defaults to true"}],"has_params":true,"tags":[{"type":"param","types":["String"],"name":"refName","description":"The property to use to uniquely identify the"},{"type":"documents","string":"in the index."},{"type":"param","types":["Boolean"],"name":"emitEvent","description":"Whether to emit add events, defaults to true"},{"type":"returns","string":"{lunr.Index}"},{"type":"memberOf","parent":"Index"}],"module":false,"parent":"Index","related":{"href":""},"has_related":true},{"id":"45-1397415736690","name":"add","signiture":"lunr.Index.prototype.add()","type":"method","ctx":{"type":"method","receiver":"lunr.Index.prototype","name":"add","string":"lunr.Index.prototype.add()"},"description":{"full":"<p>Add a document to the index.</p>\n\n<p>This is the way new documents enter the index, this function will run the<br />fields from the document through the index's pipeline and then add it to<br />the index, it will then show up in search results.</p>\n\n<p>An 'add' event is emitted with the document that has been added and the index<br />the document has been added to. This event can be silenced by passing false<br />as the second argument to add.</p>","summary":"<p>Add a document to the index.</p>","body":"<p>This is the way new documents enter the index, this function will run the<br />fields from the document through the index's pipeline and then add it to<br />the index, it will then show up in search results.</p>\n\n<p>An 'add' event is emitted with the document that has been added and the index<br />the document has been added to. This event can be silenced by passing false<br />as the second argument to add.</p>"},"full_description":"<p>Add a document to the index.</p>\n\n<p>This is the way new documents enter the index, this function will run the fields from the document through the index's pipeline and then add it to the index, it will then show up in search results.</p>\n\n<p>An 'add' event is emitted with the document that has been added and the index the document has been added to. This event can be silenced by passing false as the second argument to add.</p>","code":"lunr.Index.prototype.add = function (doc, emitEvent) {\n  var docTokens = {},\n      allDocumentTokens = new lunr.SortedSet,\n      docRef = doc[this._ref],\n      emitEvent = emitEvent === undefined ? true : emitEvent\n\n  this._fields.forEach(function (field) {\n    var fieldTokens = this.indexPipeline.run(lunr.tokenizer(doc[field.name]))\n\n    docTokens[field.name] = fieldTokens\n    lunr.SortedSet.prototype.add.apply(allDocumentTokens, fieldTokens)\n  }, this)\n\n  this.documentStore.set(docRef, allDocumentTokens)\n  lunr.SortedSet.prototype.add.apply(this.corpusTokens, allDocumentTokens.toArray())\n\n  for (var i = 0; i < allDocumentTokens.length; i++) {\n    var token = allDocumentTokens.elements[i]\n    var tf = this._fields.reduce(function (memo, field) {\n      var fieldLength = docTokens[field.name].length\n\n      if (!fieldLength) return memo\n\n      var tokenCount = docTokens[field.name].filter(function (t) { return t === token }).length\n\n      return memo + (tokenCount / fieldLength * field.boost)\n    }, 0)\n\n    this.tokenStore.add(token, { ref: docRef, tf: tf })\n  };\n\n  if (emitEvent) this.eventEmitter.emit('add', doc, this)\n}","params":[{"type":"param","types":["Object"],"name":"doc","description":"The document to add to the index."},{"type":"param","types":["Boolean"],"name":"emitEvent","description":"Whether or not to emit events, default true."}],"has_params":true,"tags":[{"type":"param","types":["Object"],"name":"doc","description":"The document to add to the index."},{"type":"param","types":["Boolean"],"name":"emitEvent","description":"Whether or not to emit events, default true."},{"type":"memberOf","parent":"Index"}],"module":false,"parent":"Index","related":{"href":""},"has_related":true},{"id":"46-1397415736690","name":"remove","signiture":"lunr.Index.prototype.remove()","type":"method","ctx":{"type":"method","receiver":"lunr.Index.prototype","name":"remove","string":"lunr.Index.prototype.remove()"},"description":{"full":"<p>Removes a document from the index.</p>\n\n<p>To make sure documents no longer show up in search results they can be<br />removed from the index using this method.</p>\n\n<p>The document passed only needs to have the same ref property value as the<br />document that was added to the index, they could be completely different<br />objects.</p>\n\n<p>A 'remove' event is emitted with the document that has been removed and the index<br />the document has been removed from. This event can be silenced by passing false<br />as the second argument to remove.</p>","summary":"<p>Removes a document from the index.</p>","body":"<p>To make sure documents no longer show up in search results they can be<br />removed from the index using this method.</p>\n\n<p>The document passed only needs to have the same ref property value as the<br />document that was added to the index, they could be completely different<br />objects.</p>\n\n<p>A 'remove' event is emitted with the document that has been removed and the index<br />the document has been removed from. This event can be silenced by passing false<br />as the second argument to remove.</p>"},"full_description":"<p>Removes a document from the index.</p>\n\n<p>To make sure documents no longer show up in search results they can be removed from the index using this method.</p>\n\n<p>The document passed only needs to have the same ref property value as the document that was added to the index, they could be completely different objects.</p>\n\n<p>A 'remove' event is emitted with the document that has been removed and the index the document has been removed from. This event can be silenced by passing false as the second argument to remove.</p>","code":"lunr.Index.prototype.remove = function (doc, emitEvent) {\n  var docRef = doc[this._ref],\n      emitEvent = emitEvent === undefined ? true : emitEvent\n\n  if (!this.documentStore.has(docRef)) return\n\n  var docTokens = this.documentStore.get(docRef)\n\n  this.documentStore.remove(docRef)\n\n  docTokens.forEach(function (token) {\n    this.tokenStore.remove(token, docRef)\n  }, this)\n\n  if (emitEvent) this.eventEmitter.emit('remove', doc, this)\n}","params":[{"type":"param","types":["Object"],"name":"doc","description":"The document to remove from the index."},{"type":"param","types":["Boolean"],"name":"emitEvent","description":"Whether to emit remove events, defaults to true"}],"has_params":true,"tags":[{"type":"param","types":["Object"],"name":"doc","description":"The document to remove from the index."},{"type":"param","types":["Boolean"],"name":"emitEvent","description":"Whether to emit remove events, defaults to true"},{"type":"memberOf","parent":"Index"}],"module":false,"parent":"Index","related":{"href":""},"has_related":true},{"id":"47-1397415736690","name":"update","signiture":"lunr.Index.prototype.update()","type":"method","ctx":{"type":"method","receiver":"lunr.Index.prototype","name":"update","string":"lunr.Index.prototype.update()"},"description":{"full":"<p>Updates a document in the index.</p>\n\n<p>When a document contained within the index gets updated, fields changed,<br />added or removed, to make sure it correctly matched against search queries,<br />it should be updated in the index.</p>\n\n<p>This method is just a wrapper around <code>remove</code> and <code>add</code></p>\n\n<p>An 'update' event is emitted with the document that has been updated and the index.<br />This event can be silenced by passing false as the second argument to update. Only<br />an update event will be fired, the 'add' and 'remove' events of the underlying calls<br />are silenced.</p>","summary":"<p>Updates a document in the index.</p>","body":"<p>When a document contained within the index gets updated, fields changed,<br />added or removed, to make sure it correctly matched against search queries,<br />it should be updated in the index.</p>\n\n<p>This method is just a wrapper around <code>remove</code> and <code>add</code></p>\n\n<p>An 'update' event is emitted with the document that has been updated and the index.<br />This event can be silenced by passing false as the second argument to update. Only<br />an update event will be fired, the 'add' and 'remove' events of the underlying calls<br />are silenced.</p>"},"full_description":"<p>Updates a document in the index.</p>\n\n<p>When a document contained within the index gets updated, fields changed, added or removed, to make sure it correctly matched against search queries, it should be updated in the index.</p>\n\n<p>This method is just a wrapper around <code>remove</code> and <code>add</code></p>\n\n<p>An 'update' event is emitted with the document that has been updated and the index. This event can be silenced by passing false as the second argument to update. Only an update event will be fired, the 'add' and 'remove' events of the underlying calls are silenced.</p>","code":"lunr.Index.prototype.update = function (doc, emitEvent) {\n  var emitEvent = emitEvent === undefined ? true : emitEvent\n\n  this.remove(doc, false)\n  this.add(doc, false)\n\n  if (emitEvent) this.eventEmitter.emit('update', doc, this)\n}","params":[{"type":"param","types":["Object"],"name":"doc","description":"The document to update in the index."},{"type":"param","types":["Boolean"],"name":"emitEvent","description":"Whether to emit update events, defaults to true"}],"has_params":true,"tags":[{"type":"param","types":["Object"],"name":"doc","description":"The document to update in the index."},{"type":"param","types":["Boolean"],"name":"emitEvent","description":"Whether to emit update events, defaults to true"},{"type":"see","local":"Index.prototype.remove","visibility":"Index.prototype.remove"},{"type":"see","local":"Index.prototype.add","visibility":"Index.prototype.add"},{"type":"memberOf","parent":"Index"}],"module":false,"parent":"Index","related":{"href":""},"has_related":true},{"id":"48-1397415736690","name":"idf","signiture":"lunr.Index.prototype.idf()","type":"method","ctx":{"type":"method","receiver":"lunr.Index.prototype","name":"idf","string":"lunr.Index.prototype.idf()"},"description":{"full":"<p>Calculates the inverse document frequency for a token within the index.</p>","summary":"<p>Calculates the inverse document frequency for a token within the index.</p>","body":""},"full_description":"<p>Calculates the inverse document frequency for a token within the index.</p>","code":"lunr.Index.prototype.idf = function (term) {\n  var cacheKey = \"@\" + term\n  if (Object.prototype.hasOwnProperty.call(this._idfCache, cacheKey)) return this._idfCache[cacheKey]\n\n  var documentFrequency = this.tokenStore.count(term),\n      idf = 1\n\n  if (documentFrequency > 0) {\n    idf = 1 + Math.log(this.tokenStore.length / documentFrequency)\n  }\n\n  return this._idfCache[cacheKey] = idf\n}","params":[{"type":"param","types":["String"],"name":"token","description":"The token to calculate the idf of."}],"has_params":true,"tags":[{"type":"param","types":["String"],"name":"token","description":"The token to calculate the idf of."},{"type":"see","local":"Index.prototype.idf","visibility":"Index.prototype.idf"},{"type":"private","string":""},{"type":"memberOf","parent":"Index"}],"module":false,"parent":"Index","related":{"href":""},"has_related":true},{"id":"49-1397415736690","name":"search","signiture":"lunr.Index.prototype.search()","type":"method","ctx":{"type":"method","receiver":"lunr.Index.prototype","name":"search","string":"lunr.Index.prototype.search()"},"description":{"full":"<p>Searches the index using the passed query.</p>\n\n<p>Queries should be a string, multiple words are allowed and will lead to an<br />AND based query, e.g. <code>idx.search('foo bar')</code> will run a search for<br />documents containing both 'foo' and 'bar'.</p>\n\n<p>All query tokens are passed through the same pipeline that document tokens<br />are passed through, so any language processing involved will be run on every<br />query term.</p>\n\n<p>Each query term is expanded, so that the term 'he' might be expanded to<br />'hello' and 'help' if those terms were already included in the index.</p>\n\n<p>Matching documents are returned as an array of objects, each object contains<br />the matching document ref, as set for this index, and the similarity score<br />for this document against the query.</p>","summary":"<p>Searches the index using the passed query.</p>","body":"<p>Queries should be a string, multiple words are allowed and will lead to an<br />AND based query, e.g. <code>idx.search('foo bar')</code> will run a search for<br />documents containing both 'foo' and 'bar'.</p>\n\n<p>All query tokens are passed through the same pipeline that document tokens<br />are passed through, so any language processing involved will be run on every<br />query term.</p>\n\n<p>Each query term is expanded, so that the term 'he' might be expanded to<br />'hello' and 'help' if those terms were already included in the index.</p>\n\n<p>Matching documents are returned as an array of objects, each object contains<br />the matching document ref, as set for this index, and the similarity score<br />for this document against the query.</p>"},"full_description":"<p>Searches the index using the passed query.</p>\n\n<p>Queries should be a string, multiple words are allowed and will lead to an AND based query, e.g. <code>idx.search('foo bar')</code> will run a search for documents containing both 'foo' and 'bar'.</p>\n\n<p>All query tokens are passed through the same pipeline that document tokens are passed through, so any language processing involved will be run on every query term.</p>\n\n<p>Each query term is expanded, so that the term 'he' might be expanded to 'hello' and 'help' if those terms were already included in the index.</p>\n\n<p>Matching documents are returned as an array of objects, each object contains the matching document ref, as set for this index, and the similarity score for this document against the query.</p>","code":"lunr.Index.prototype.search = function (query) {\n  var queryTokens = this.searchPipeline.run(lunr.tokenizer(query)),\n      queryVector = new lunr.Vector,\n      documentSets = [],\n      fieldBoosts = this._fields.reduce(function (memo, f) { return memo + f.boost }, 0)\n\n  var hasSomeToken = queryTokens.some(function (token) {\n    return this.tokenStore.has(token)\n  }, this)\n\n  if (!hasSomeToken) return []\n\n  queryTokens\n    .forEach(function (token, i, tokens) {\n      var tf = 1 / tokens.length * this._fields.length * fieldBoosts,\n          self = this\n\n      var set = this.tokenStore.expand(token).reduce(function (memo, key) {\n        var pos = self.corpusTokens.indexOf(key),\n            idf = self.idf(key),\n            similarityBoost = 1,\n            set = new lunr.SortedSet\n\n        // if the expanded key is not an exact match to the token then\n        // penalise the score for this key by how different the key is\n        // to the token.\n        if (key !== token) {\n          var diff = Math.max(3, key.length - token.length)\n          similarityBoost = 1 / Math.log(diff)\n        }\n\n        // calculate the query tf-idf score for this token\n        // applying an similarityBoost to ensure exact matches\n        // these rank higher than expanded terms\n        if (pos > -1) queryVector.insert(pos, tf * idf * similarityBoost)\n\n        // add all the documents that have this key into a set\n        Object.keys(self.tokenStore.get(key)).forEach(function (ref) { set.add(ref) })\n\n        return memo.union(set)\n      }, new lunr.SortedSet)\n\n      documentSets.push(set)\n    }, this)\n\n  var documentSet = documentSets.reduce(function (memo, set) {\n    return memo.intersect(set)\n  })\n\n  return documentSet\n    .map(function (ref) {\n      return { ref: ref, score: queryVector.similarity(this.documentVector(ref)) }\n    }, this)\n    .sort(function (a, b) {\n      return b.score - a.score\n    })\n}","params":[{"type":"param","types":["String"],"name":"query","description":"The query to search the index with."}],"has_params":true,"tags":[{"type":"param","types":["String"],"name":"query","description":"The query to search the index with."},{"type":"returns","string":"{Object}"},{"type":"see","local":"Index.prototype.idf","visibility":"Index.prototype.idf"},{"type":"see","local":"Index.prototype.documentVector","visibility":"Index.prototype.documentVector"},{"type":"memberOf","parent":"Index"}],"module":false,"parent":"Index","related":{"href":""},"has_related":true},{"id":"50-1397415736690","name":"documentVector","signiture":"lunr.Index.prototype.documentVector()","type":"method","ctx":{"type":"method","receiver":"lunr.Index.prototype","name":"documentVector","string":"lunr.Index.prototype.documentVector()"},"description":{"full":"<p>Generates a vector containing all the tokens in the document matching the<br />passed documentRef.</p>\n\n<p>The vector contains the tf-idf score for each token contained in the<br />document with the passed documentRef.  The vector will contain an element<br />for every token in the indexes corpus, if the document does not contain that<br />token the element will be 0.</p>","summary":"<p>Generates a vector containing all the tokens in the document matching the<br />passed documentRef.</p>","body":"<p>The vector contains the tf-idf score for each token contained in the<br />document with the passed documentRef.  The vector will contain an element<br />for every token in the indexes corpus, if the document does not contain that<br />token the element will be 0.</p>"},"full_description":"<p>Generates a vector containing all the tokens in the document matching the passed documentRef.</p>\n\n<p>The vector contains the tf-idf score for each token contained in the document with the passed documentRef.  The vector will contain an element for every token in the indexes corpus, if the document does not contain that token the element will be 0.</p>","code":"lunr.Index.prototype.documentVector = function (documentRef) {\n  var documentTokens = this.documentStore.get(documentRef),\n      documentTokensLength = documentTokens.length,\n      documentVector = new lunr.Vector\n\n  for (var i = 0; i < documentTokensLength; i++) {\n    var token = documentTokens.elements[i],\n        tf = this.tokenStore.get(token)[documentRef].tf,\n        idf = this.idf(token)\n\n    documentVector.insert(this.corpusTokens.indexOf(token), tf * idf)\n  };\n\n  return documentVector\n}","params":[{"type":"param","types":["Object"],"name":"documentRef","description":"The ref to find the document with."}],"has_params":true,"tags":[{"type":"param","types":["Object"],"name":"documentRef","description":"The ref to find the document with."},{"type":"returns","string":"{lunr.Vector}"},{"type":"private","string":""},{"type":"memberOf","parent":"Index"}],"module":false,"parent":"Index","related":{"href":""},"has_related":true},{"id":"51-1397415736690","name":"toJSON","signiture":"lunr.Index.prototype.toJSON()","type":"method","ctx":{"type":"method","receiver":"lunr.Index.prototype","name":"toJSON","string":"lunr.Index.prototype.toJSON()"},"description":{"full":"<p>Returns a representation of the index ready for serialisation.</p>","summary":"<p>Returns a representation of the index ready for serialisation.</p>","body":""},"full_description":"<p>Returns a representation of the index ready for serialisation.</p>","code":"lunr.Index.prototype.toJSON = function () {\n  return {\n    version: lunr.version,\n    fields: this._fields,\n    ref: this._ref,\n    documentStore: this.documentStore.toJSON(),\n    tokenStore: this.tokenStore.toJSON(),\n    corpusTokens: this.corpusTokens.toJSON(),\n    indexPipeline: this.indexPipeline.toJSON(),\n    searchPipeline: this.searchPipeline.toJSON()\n  }\n}","params":[],"has_params":false,"tags":[{"type":"returns","string":"{Object}"},{"type":"memberOf","parent":"Index"}],"module":false,"parent":"Index","related":{"href":""},"has_related":true},{"id":"52-1397415736690","name":"use","signiture":"lunr.Index.prototype.use()","type":"method","ctx":{"type":"method","receiver":"lunr.Index.prototype","name":"use","string":"lunr.Index.prototype.use()"},"description":{"full":"<p>Applies a plugin to the current index.</p>\n\n<p>A plugin is a function that is called with the index as its context.<br />Plugins can be used to customise or extend the behaviour the index<br />in some way. A plugin is just a function, that encapsulated the custom<br />behaviour that should be applied to the index.</p>\n\n<p>The plugin function will be called with the index as its argument, additional<br />arguments can also be passed when calling use. The function will be called<br />with the index as its context.</p>\n\n<p>Example:</p>\n\n<pre><code>var myPlugin = function (idx, arg1, arg2) {\n  // `this` is the index to be extended\n  // apply any extensions etc here.\n}\n\nvar idx = lunr(function () {\n  this.use(myPlugin, 'arg1', 'arg2')\n})\n</code></pre>","summary":"<p>Applies a plugin to the current index.</p>","body":"<p>A plugin is a function that is called with the index as its context.<br />Plugins can be used to customise or extend the behaviour the index<br />in some way. A plugin is just a function, that encapsulated the custom<br />behaviour that should be applied to the index.</p>\n\n<p>The plugin function will be called with the index as its argument, additional<br />arguments can also be passed when calling use. The function will be called<br />with the index as its context.</p>\n\n<p>Example:</p>\n\n<pre><code>var myPlugin = function (idx, arg1, arg2) {\n  // `this` is the index to be extended\n  // apply any extensions etc here.\n}\n\nvar idx = lunr(function () {\n  this.use(myPlugin, 'arg1', 'arg2')\n})\n</code></pre>"},"full_description":"<p>Applies a plugin to the current index.</p>\n\n<p>A plugin is a function that is called with the index as its context. Plugins can be used to customise or extend the behaviour the index in some way. A plugin is just a function, that encapsulated the custom behaviour that should be applied to the index.</p>\n\n<p>The plugin function will be called with the index as its argument, additional arguments can also be passed when calling use. The function will be called with the index as its context.</p>\n\n<p>Example:</p>\n\n<pre><code>var myPlugin = function (idx, arg1, arg2) {\n  // `this` is the index to be extended\n  // apply any extensions etc here.\n}\n\nvar idx = lunr(function () {\n  this.use(myPlugin, 'arg1', 'arg2')\n})\n</code></pre>","code":"lunr.Index.prototype.use = function (plugin) {\n  var args = Array.prototype.slice.call(arguments, 1)\n  args.unshift(this)\n  plugin.apply(this, args)\n}","params":[{"type":"param","types":["Function"],"name":"plugin","description":"The plugin to apply."}],"has_params":true,"tags":[{"type":"param","types":["Function"],"name":"plugin","description":"The plugin to apply."},{"type":"memberOf","parent":"Index"}],"module":false,"parent":"Index","related":{"href":""},"has_related":true}]},{"id":"53-1397415736690","name":"Store","signiture":"lunr.Store()","type":"method","ctx":{"type":"method","receiver":"lunr","name":"Store","string":"lunr.Store()"},"description":{"full":"<p>lunr.Store is a simple key-value store used for storing sets of tokens for<br />documents stored in index.</p>","summary":"<p>lunr.Store is a simple key-value store used for storing sets of tokens for<br />documents stored in index.</p>","body":""},"full_description":"<p>lunr.Store is a simple key-value store used for storing sets of tokens for documents stored in index.</p>","code":"lunr.Store = function () {\n  this.store = {}\n  this.length = 0\n}","params":[],"has_params":false,"tags":[{"type":"constructor","string":""},{"type":"module","string":""}],"module":true,"related":{"href":""},"has_related":true,"methods":[{"id":"54-1397415736690","name":"load","signiture":"lunr.Store.load()","type":"method","ctx":{"type":"method","receiver":"lunr.Store","name":"load","string":"lunr.Store.load()"},"description":{"full":"<p>Loads a previously serialised store</p>","summary":"<p>Loads a previously serialised store</p>","body":""},"full_description":"<p>Loads a previously serialised store</p>","code":"lunr.Store.load = function (serialisedData) {\n  var store = new this\n\n  store.length = serialisedData.length\n  store.store = Object.keys(serialisedData.store).reduce(function (memo, key) {\n    memo[key] = lunr.SortedSet.load(serialisedData.store[key])\n    return memo\n  }, {})\n\n  return store\n}","params":[{"type":"param","types":["Object"],"name":"serialisedData","description":"The serialised store to load."}],"has_params":true,"tags":[{"type":"param","types":["Object"],"name":"serialisedData","description":"The serialised store to load."},{"type":"returns","string":"{lunr.Store}"},{"type":"memberOf","parent":"Store"}],"module":false,"parent":"Store","related":{"href":""},"has_related":true},{"id":"55-1397415736690","name":"set","signiture":"lunr.Store.prototype.set()","type":"method","ctx":{"type":"method","receiver":"lunr.Store.prototype","name":"set","string":"lunr.Store.prototype.set()"},"description":{"full":"<p>Stores the given tokens in the store against the given id.</p>","summary":"<p>Stores the given tokens in the store against the given id.</p>","body":""},"full_description":"<p>Stores the given tokens in the store against the given id.</p>","code":"lunr.Store.prototype.set = function (id, tokens) {\n  this.store[id] = tokens\n  this.length = Object.keys(this.store).length\n}","params":[{"type":"param","types":["Object"],"name":"id","description":"The key used to store the tokens against."},{"type":"param","types":["Object"],"name":"tokens","description":"The tokens to store against the key."}],"has_params":true,"tags":[{"type":"param","types":["Object"],"name":"id","description":"The key used to store the tokens against."},{"type":"param","types":["Object"],"name":"tokens","description":"The tokens to store against the key."},{"type":"memberOf","parent":"Store"}],"module":false,"parent":"Store","related":{"href":""},"has_related":true},{"id":"56-1397415736690","name":"get","signiture":"lunr.Store.prototype.get()","type":"method","ctx":{"type":"method","receiver":"lunr.Store.prototype","name":"get","string":"lunr.Store.prototype.get()"},"description":{"full":"<p>Retrieves the tokens from the store for a given key.</p>","summary":"<p>Retrieves the tokens from the store for a given key.</p>","body":""},"full_description":"<p>Retrieves the tokens from the store for a given key.</p>","code":"lunr.Store.prototype.get = function (id) {\n  return this.store[id]\n}","params":[{"type":"param","types":["Object"],"name":"id","description":"The key to lookup and retrieve from the store."}],"has_params":true,"tags":[{"type":"param","types":["Object"],"name":"id","description":"The key to lookup and retrieve from the store."},{"type":"returns","string":"{Object}"},{"type":"memberOf","parent":"Store"}],"module":false,"parent":"Store","related":{"href":""},"has_related":true},{"id":"57-1397415736690","name":"has","signiture":"lunr.Store.prototype.has()","type":"method","ctx":{"type":"method","receiver":"lunr.Store.prototype","name":"has","string":"lunr.Store.prototype.has()"},"description":{"full":"<p>Checks whether the store contains a key.</p>","summary":"<p>Checks whether the store contains a key.</p>","body":""},"full_description":"<p>Checks whether the store contains a key.</p>","code":"lunr.Store.prototype.has = function (id) {\n  return id in this.store\n}","params":[{"type":"param","types":["Object"],"name":"id","description":"The id to look up in the store."}],"has_params":true,"tags":[{"type":"param","types":["Object"],"name":"id","description":"The id to look up in the store."},{"type":"returns","string":"{Boolean}"},{"type":"memberOf","parent":"Store"}],"module":false,"parent":"Store","related":{"href":""},"has_related":true},{"id":"58-1397415736690","name":"remove","signiture":"lunr.Store.prototype.remove()","type":"method","ctx":{"type":"method","receiver":"lunr.Store.prototype","name":"remove","string":"lunr.Store.prototype.remove()"},"description":{"full":"<p>Removes the value for a key in the store.</p>","summary":"<p>Removes the value for a key in the store.</p>","body":""},"full_description":"<p>Removes the value for a key in the store.</p>","code":"lunr.Store.prototype.remove = function (id) {\n  if (!this.has(id)) return\n\n  delete this.store[id]\n  this.length--\n}","params":[{"type":"param","types":["Object"],"name":"id","description":"The id to remove from the store."}],"has_params":true,"tags":[{"type":"param","types":["Object"],"name":"id","description":"The id to remove from the store."},{"type":"memberOf","parent":"Store"}],"module":false,"parent":"Store","related":{"href":""},"has_related":true},{"id":"59-1397415736690","name":"toJSON","signiture":"lunr.Store.prototype.toJSON()","type":"method","ctx":{"type":"method","receiver":"lunr.Store.prototype","name":"toJSON","string":"lunr.Store.prototype.toJSON()"},"description":{"full":"<p>Returns a representation of the store ready for serialisation.</p>","summary":"<p>Returns a representation of the store ready for serialisation.</p>","body":""},"full_description":"<p>Returns a representation of the store ready for serialisation.</p>","code":"lunr.Store.prototype.toJSON = function () {\n  return {\n    store: this.store,\n    length: this.length\n  }\n}","params":[],"has_params":false,"tags":[{"type":"returns","string":"{Object}"},{"type":"memberOf","parent":"Store"}],"module":false,"parent":"Store","related":{"href":""},"has_related":true}]},{"id":"60-1397415736691","name":"stemmer","signiture":"lunr.stemmer","type":"property","ctx":{"type":"property","receiver":"lunr","name":"stemmer","value":"(function(){","string":"lunr.stemmer"},"description":{"full":"<p>lunr.stemmer is an english language stemmer, this is a JavaScript<br />implementation of the PorterStemmer taken from <a href='http://tartaurs.org/~martin'>http://tartaurs.org/~martin</a></p>","summary":"<p>lunr.stemmer is an english language stemmer, this is a JavaScript<br />implementation of the PorterStemmer taken from <a href='http://tartaurs.org/~martin'>http://tartaurs.org/~martin</a></p>","body":""},"full_description":"<p>lunr.stemmer is an english language stemmer, this is a JavaScript implementation of the PorterStemmer taken from <a href='http://tartaurs.org/~martin'>http://tartaurs.org/~martin</a></p>","code":"lunr.stemmer = (function(){\n  var step2list = {\n      \"ational\" : \"ate\",\n      \"tional\" : \"tion\",\n      \"enci\" : \"ence\",\n      \"anci\" : \"ance\",\n      \"izer\" : \"ize\",\n      \"bli\" : \"ble\",\n      \"alli\" : \"al\",\n      \"entli\" : \"ent\",\n      \"eli\" : \"e\",\n      \"ousli\" : \"ous\",\n      \"ization\" : \"ize\",\n      \"ation\" : \"ate\",\n      \"ator\" : \"ate\",\n      \"alism\" : \"al\",\n      \"iveness\" : \"ive\",\n      \"fulness\" : \"ful\",\n      \"ousness\" : \"ous\",\n      \"aliti\" : \"al\",\n      \"iviti\" : \"ive\",\n      \"biliti\" : \"ble\",\n      \"logi\" : \"log\"\n    },\n\n    step3list = {\n      \"icate\" : \"ic\",\n      \"ative\" : \"\",\n      \"alize\" : \"al\",\n      \"iciti\" : \"ic\",\n      \"ical\" : \"ic\",\n      \"ful\" : \"\",\n      \"ness\" : \"\"\n    },\n\n    c = \"[^aeiou]\",          // consonant\n    v = \"[aeiouy]\",          // vowel\n    C = c + \"[^aeiouy]*\",    // consonant sequence\n    V = v + \"[aeiou]*\",      // vowel sequence\n\n    mgr0 = \"^(\" + C + \")?\" + V + C,               // [C]VC... is m>0\n    meq1 = \"^(\" + C + \")?\" + V + C + \"(\" + V + \")?$\",  // [C]VC[V] is m=1\n    mgr1 = \"^(\" + C + \")?\" + V + C + V + C,       // [C]VCVC... is m>1\n    s_v = \"^(\" + C + \")?\" + v;                   // vowel in stem\n\n  return function (w) {\n    var   stem,\n      suffix,\n      firstch,\n      re,\n      re2,\n      re3,\n      re4;\n\n    if (w.length < 3) { return w; }\n\n    firstch = w.substr(0,1);\n    if (firstch == \"y\") {\n      w = firstch.toUpperCase() + w.substr(1);\n    }\n\n    // Step 1a\n    re = /^(.+?)(ss|i)es$/;\n    re2 = /^(.+?)([^s])s$/;\n\n    if (re.test(w)) { w = w.replace(re,\"$1$2\"); }\n    else if (re2.test(w)) { w = w.replace(re2,\"$1$2\"); }\n\n    // Step 1b\n    re = /^(.+?)eed$/;\n    re2 = /^(.+?)(ed|ing)$/;\n    if (re.test(w)) {\n      var fp = re.exec(w);\n      re = new RegExp(mgr0);\n      if (re.test(fp[1])) {\n        re = /.$/;\n        w = w.replace(re,\"\");\n      }\n    } else if (re2.test(w)) {\n      var fp = re2.exec(w);\n      stem = fp[1];\n      re2 = new RegExp(s_v);\n      if (re2.test(stem)) {\n        w = stem;\n        re2 = /(at|bl|iz)$/;\n        re3 = new RegExp(\"([^aeiouylsz])\\\\1$\");\n        re4 = new RegExp(\"^\" + C + v + \"[^aeiouwxy]$\");\n        if (re2.test(w)) {  w = w + \"e\"; }\n        else if (re3.test(w)) { re = /.$/; w = w.replace(re,\"\"); }\n        else if (re4.test(w)) { w = w + \"e\"; }\n      }\n    }\n\n    // Step 1c\n    re = /^(.+?)y$/;\n    if (re.test(w)) {\n      var fp = re.exec(w);\n      stem = fp[1];\n      re = new RegExp(s_v);\n      if (re.test(stem)) { w = stem + \"i\"; }\n    }\n\n    // Step 2\n    re = /^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/;\n    if (re.test(w)) {\n      var fp = re.exec(w);\n      stem = fp[1];\n      suffix = fp[2];\n      re = new RegExp(mgr0);\n      if (re.test(stem)) {\n        w = stem + step2list[suffix];\n      }\n    }\n\n    // Step 3\n    re = /^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/;\n    if (re.test(w)) {\n      var fp = re.exec(w);\n      stem = fp[1];\n      suffix = fp[2];\n      re = new RegExp(mgr0);\n      if (re.test(stem)) {\n        w = stem + step3list[suffix];\n      }\n    }\n\n    // Step 4\n    re = /^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/;\n    re2 = /^(.+?)(s|t)(ion)$/;\n    if (re.test(w)) {\n      var fp = re.exec(w);\n      stem = fp[1];\n      re = new RegExp(mgr1);\n      if (re.test(stem)) {\n        w = stem;\n      }\n    } else if (re2.test(w)) {\n      var fp = re2.exec(w);\n      stem = fp[1] + fp[2];\n      re2 = new RegExp(mgr1);\n      if (re2.test(stem)) {\n        w = stem;\n      }\n    }\n\n    // Step 5\n    re = /^(.+?)e$/;\n    if (re.test(w)) {\n      var fp = re.exec(w);\n      stem = fp[1];\n      re = new RegExp(mgr1);\n      re2 = new RegExp(meq1);\n      re3 = new RegExp(\"^\" + C + v + \"[^aeiouwxy]$\");\n      if (re.test(stem) || (re2.test(stem) && !(re3.test(stem)))) {\n        w = stem;\n      }\n    }\n\n    re = /ll$/;\n    re2 = new RegExp(mgr1);\n    if (re.test(w) && re2.test(w)) {\n      re = /.$/;\n      w = w.replace(re,\"\");\n    }\n\n    // and turn initial Y back to y\n\n    if (firstch == \"y\") {\n      w = firstch.toLowerCase() + w.substr(1);\n    }\n\n    return w;\n  }\n})();\n\nlunr.Pipeline.registerFunction(lunr.stemmer, 'stemmer')","params":[{"type":"param","types":["String"],"name":"str","description":"The string to stem"}],"has_params":true,"tags":[{"type":"module","string":""},{"type":"param","types":["String"],"name":"str","description":"The string to stem"},{"type":"returns","string":"{String}"},{"type":"see","local":"lunr.Pipeline","visibility":"lunr.Pipeline"}],"module":true,"related":{"href":""},"has_related":true,"methods":[]},{"id":"61-1397415736691","name":"stopWordFilter","signiture":"lunr.stopWordFilter()","type":"method","ctx":{"type":"method","receiver":"lunr","name":"stopWordFilter","string":"lunr.stopWordFilter()"},"description":{"full":"<p>lunr.stopWordFilter is an English language stop word list filter, any words<br />contained in the list will not be passed through the filter.</p>\n\n<p>This is intended to be used in the Pipeline. If the token does not pass the<br />filter then undefined will be returned.</p>","summary":"<p>lunr.stopWordFilter is an English language stop word list filter, any words<br />contained in the list will not be passed through the filter.</p>","body":"<p>This is intended to be used in the Pipeline. If the token does not pass the<br />filter then undefined will be returned.</p>"},"full_description":"<p>lunr.stopWordFilter is an English language stop word list filter, any words contained in the list will not be passed through the filter.</p>\n\n<p>This is intended to be used in the Pipeline. If the token does not pass the filter then undefined will be returned.</p>","code":"lunr.stopWordFilter = function (token) {\n  if (lunr.stopWordFilter.stopWords.indexOf(token) === -1) return token\n}\n\nlunr.stopWordFilter.stopWords = new lunr.SortedSet\nlunr.stopWordFilter.stopWords.length = 119\nlunr.stopWordFilter.stopWords.elements = [\n  \"\",\n  \"a\",\n  \"able\",\n  \"about\",\n  \"across\",\n  \"after\",\n  \"all\",\n  \"almost\",\n  \"also\",\n  \"am\",\n  \"among\",\n  \"an\",\n  \"and\",\n  \"any\",\n  \"are\",\n  \"as\",\n  \"at\",\n  \"be\",\n  \"because\",\n  \"been\",\n  \"but\",\n  \"by\",\n  \"can\",\n  \"cannot\",\n  \"could\",\n  \"dear\",\n  \"did\",\n  \"do\",\n  \"does\",\n  \"either\",\n  \"else\",\n  \"ever\",\n  \"every\",\n  \"for\",\n  \"from\",\n  \"get\",\n  \"got\",\n  \"had\",\n  \"has\",\n  \"have\",\n  \"he\",\n  \"her\",\n  \"hers\",\n  \"him\",\n  \"his\",\n  \"how\",\n  \"however\",\n  \"i\",\n  \"if\",\n  \"in\",\n  \"into\",\n  \"is\",\n  \"it\",\n  \"its\",\n  \"just\",\n  \"least\",\n  \"let\",\n  \"like\",\n  \"likely\",\n  \"may\",\n  \"me\",\n  \"might\",\n  \"most\",\n  \"must\",\n  \"my\",\n  \"neither\",\n  \"no\",\n  \"nor\",\n  \"not\",\n  \"of\",\n  \"off\",\n  \"often\",\n  \"on\",\n  \"only\",\n  \"or\",\n  \"other\",\n  \"our\",\n  \"own\",\n  \"rather\",\n  \"said\",\n  \"say\",\n  \"says\",\n  \"she\",\n  \"should\",\n  \"since\",\n  \"so\",\n  \"some\",\n  \"than\",\n  \"that\",\n  \"the\",\n  \"their\",\n  \"them\",\n  \"then\",\n  \"there\",\n  \"these\",\n  \"they\",\n  \"this\",\n  \"tis\",\n  \"to\",\n  \"too\",\n  \"twas\",\n  \"us\",\n  \"wants\",\n  \"was\",\n  \"we\",\n  \"were\",\n  \"what\",\n  \"when\",\n  \"where\",\n  \"which\",\n  \"while\",\n  \"who\",\n  \"whom\",\n  \"why\",\n  \"will\",\n  \"with\",\n  \"would\",\n  \"yet\",\n  \"you\",\n  \"your\"\n]\n\nlunr.Pipeline.registerFunction(lunr.stopWordFilter, 'stopWordFilter')","params":[{"type":"param","types":["String"],"name":"token","description":"The token to pass through the filter"}],"has_params":true,"tags":[{"type":"module","string":""},{"type":"param","types":["String"],"name":"token","description":"The token to pass through the filter"},{"type":"returns","string":"{String}"},{"type":"see","local":"lunr.Pipeline","visibility":"lunr.Pipeline"}],"module":true,"related":{"href":""},"has_related":true,"methods":[]},{"id":"62-1397415736691","name":"trimmer","signiture":"lunr.trimmer()","type":"method","ctx":{"type":"method","receiver":"lunr","name":"trimmer","string":"lunr.trimmer()"},"description":{"full":"<p>lunr.trimmer is a pipeline function for trimming non word<br />characters from the begining and end of tokens before they<br />enter the index.</p>\n\n<p>This implementation may not work correctly for non latin<br />characters and should either be removed or adapted for use<br />with languages with non-latin characters.</p>","summary":"<p>lunr.trimmer is a pipeline function for trimming non word<br />characters from the begining and end of tokens before they<br />enter the index.</p>","body":"<p>This implementation may not work correctly for non latin<br />characters and should either be removed or adapted for use<br />with languages with non-latin characters.</p>"},"full_description":"<p>lunr.trimmer is a pipeline function for trimming non word characters from the begining and end of tokens before they enter the index.</p>\n\n<p>This implementation may not work correctly for non latin characters and should either be removed or adapted for use with languages with non-latin characters.</p>","code":"lunr.trimmer = function (token) {\n  return token\n    .replace(/^\\W+/, '')\n    .replace(/\\W+$/, '')\n}\n\nlunr.Pipeline.registerFunction(lunr.trimmer, 'trimmer')","params":[{"type":"param","types":["String"],"name":"token","description":"The token to pass through the filter"}],"has_params":true,"tags":[{"type":"module","string":""},{"type":"param","types":["String"],"name":"token","description":"The token to pass through the filter"},{"type":"returns","string":"{String}"},{"type":"see","local":"lunr.Pipeline","visibility":"lunr.Pipeline"}],"module":true,"related":{"href":""},"has_related":true,"methods":[]},{"id":"63-1397415736691","name":"TokenStore","signiture":"lunr.TokenStore()","type":"method","ctx":{"type":"method","receiver":"lunr","name":"TokenStore","string":"lunr.TokenStore()"},"description":{"full":"<p>lunr.TokenStore is used for efficient storing and lookup of the reverse<br />index of token to document ref.</p>","summary":"<p>lunr.TokenStore is used for efficient storing and lookup of the reverse<br />index of token to document ref.</p>","body":""},"full_description":"<p>lunr.TokenStore is used for efficient storing and lookup of the reverse index of token to document ref.</p>","code":"lunr.TokenStore = function () {\n  this.root = { docs: {} }\n  this.length = 0\n}","params":[],"has_params":false,"tags":[{"type":"constructor","string":""}],"module":true,"related":{"href":""},"has_related":true,"methods":[{"id":"64-1397415736691","name":"load","signiture":"lunr.TokenStore.load()","type":"method","ctx":{"type":"method","receiver":"lunr.TokenStore","name":"load","string":"lunr.TokenStore.load()"},"description":{"full":"<p>Loads a previously serialised token store</p>","summary":"<p>Loads a previously serialised token store</p>","body":""},"full_description":"<p>Loads a previously serialised token store</p>","code":"lunr.TokenStore.load = function (serialisedData) {\n  var store = new this\n\n  store.root = serialisedData.root\n  store.length = serialisedData.length\n\n  return store\n}","params":[{"type":"param","types":["Object"],"name":"serialisedData","description":"The serialised token store to load."}],"has_params":true,"tags":[{"type":"param","types":["Object"],"name":"serialisedData","description":"The serialised token store to load."},{"type":"returns","string":"{lunr.TokenStore}"},{"type":"memberOf","parent":"TokenStore"}],"module":false,"parent":"TokenStore","related":{"href":""},"has_related":true},{"id":"65-1397415736691","name":"add","signiture":"lunr.TokenStore.prototype.add()","type":"method","ctx":{"type":"method","receiver":"lunr.TokenStore.prototype","name":"add","string":"lunr.TokenStore.prototype.add()"},"description":{"full":"<p>Adds a new token doc pair to the store.</p>\n\n<p>By default this function starts at the root of the current store, however<br />it can start at any node of any token store if required.</p>","summary":"<p>Adds a new token doc pair to the store.</p>","body":"<p>By default this function starts at the root of the current store, however<br />it can start at any node of any token store if required.</p>"},"full_description":"<p>Adds a new token doc pair to the store.</p>\n\n<p>By default this function starts at the root of the current store, however it can start at any node of any token store if required.</p>","code":"lunr.TokenStore.prototype.add = function (token, doc, root) {\n  var root = root || this.root,\n      key = token[0],\n      rest = token.slice(1)\n\n  if (!(key in root)) root[key] = {docs: {}}\n\n  if (rest.length === 0) {\n    root[key].docs[doc.ref] = doc\n    this.length += 1\n    return\n  } else {\n    return this.add(rest, doc, root[key])\n  }\n}","params":[{"type":"param","types":["String"],"name":"token","description":"The token to store the doc under"},{"type":"param","types":["Object"],"name":"doc","description":"The doc to store against the token"},{"type":"param","types":["Object"],"name":"root","description":"An optional node at which to start looking for the"}],"has_params":true,"tags":[{"type":"param","types":["String"],"name":"token","description":"The token to store the doc under"},{"type":"param","types":["Object"],"name":"doc","description":"The doc to store against the token"},{"type":"param","types":["Object"],"name":"root","description":"An optional node at which to start looking for the"},{"type":"correct","string":"place to enter the doc, by default the root of this lunr.TokenStore"},{"type":"is","string":"used."},{"type":"memberOf","parent":"TokenStore"}],"module":false,"parent":"TokenStore","related":{"href":""},"has_related":true},{"id":"66-1397415736691","name":"has","signiture":"lunr.TokenStore.prototype.has()","type":"method","ctx":{"type":"method","receiver":"lunr.TokenStore.prototype","name":"has","string":"lunr.TokenStore.prototype.has()"},"description":{"full":"<p>Checks whether this key is contained within this lunr.TokenStore.</p>\n\n<p>By default this function starts at the root of the current store, however<br />it can start at any node of any token store if required.</p>","summary":"<p>Checks whether this key is contained within this lunr.TokenStore.</p>","body":"<p>By default this function starts at the root of the current store, however<br />it can start at any node of any token store if required.</p>"},"full_description":"<p>Checks whether this key is contained within this lunr.TokenStore.</p>\n\n<p>By default this function starts at the root of the current store, however it can start at any node of any token store if required.</p>","code":"lunr.TokenStore.prototype.has = function (token) {\n  if (!token) return false\n\n  var node = this.root\n\n  for (var i = 0; i < token.length; i++) {\n    if (!node[token[i]]) return false\n\n    node = node[token[i]]\n  }\n\n  return true\n}","params":[{"type":"param","types":["String"],"name":"token","description":"The token to check for"},{"type":"param","types":["Object"],"name":"root","description":"An optional node at which to start"}],"has_params":true,"tags":[{"type":"param","types":["String"],"name":"token","description":"The token to check for"},{"type":"param","types":["Object"],"name":"root","description":"An optional node at which to start"},{"type":"memberOf","parent":"TokenStore"}],"module":false,"parent":"TokenStore","related":{"href":""},"has_related":true},{"id":"67-1397415736691","name":"getNode","signiture":"lunr.TokenStore.prototype.getNode()","type":"method","ctx":{"type":"method","receiver":"lunr.TokenStore.prototype","name":"getNode","string":"lunr.TokenStore.prototype.getNode()"},"description":{"full":"<p>Retrieve a node from the token store for a given token.</p>\n\n<p>By default this function starts at the root of the current store, however<br />it can start at any node of any token store if required.</p>","summary":"<p>Retrieve a node from the token store for a given token.</p>","body":"<p>By default this function starts at the root of the current store, however<br />it can start at any node of any token store if required.</p>"},"full_description":"<p>Retrieve a node from the token store for a given token.</p>\n\n<p>By default this function starts at the root of the current store, however it can start at any node of any token store if required.</p>","code":"lunr.TokenStore.prototype.getNode = function (token) {\n  if (!token) return {}\n\n  var node = this.root\n\n  for (var i = 0; i < token.length; i++) {\n    if (!node[token[i]]) return {}\n\n    node = node[token[i]]\n  }\n\n  return node\n}","params":[{"type":"param","types":["String"],"name":"token","description":"The token to get the node for."},{"type":"param","types":["Object"],"name":"root","description":"An optional node at which to start."}],"has_params":true,"tags":[{"type":"param","types":["String"],"name":"token","description":"The token to get the node for."},{"type":"param","types":["Object"],"name":"root","description":"An optional node at which to start."},{"type":"returns","string":"{Object}"},{"type":"see","local":"TokenStore.prototype.get","visibility":"TokenStore.prototype.get"},{"type":"memberOf","parent":"TokenStore"}],"module":false,"parent":"TokenStore","related":{"href":""},"has_related":true},{"id":"68-1397415736691","name":"get","signiture":"lunr.TokenStore.prototype.get()","type":"method","ctx":{"type":"method","receiver":"lunr.TokenStore.prototype","name":"get","string":"lunr.TokenStore.prototype.get()"},"description":{"full":"<p>Retrieve the documents for a node for the given token.</p>\n\n<p>By default this function starts at the root of the current store, however<br />it can start at any node of any token store if required.</p>","summary":"<p>Retrieve the documents for a node for the given token.</p>","body":"<p>By default this function starts at the root of the current store, however<br />it can start at any node of any token store if required.</p>"},"full_description":"<p>Retrieve the documents for a node for the given token.</p>\n\n<p>By default this function starts at the root of the current store, however it can start at any node of any token store if required.</p>","code":"lunr.TokenStore.prototype.get = function (token, root) {\n  return this.getNode(token, root).docs || {}\n}\n\nlunr.TokenStore.prototype.count = function (token, root) {\n  return Object.keys(this.get(token, root)).length\n}","params":[{"type":"param","types":["String"],"name":"token","description":"The token to get the documents for."},{"type":"param","types":["Object"],"name":"root","description":"An optional node at which to start."}],"has_params":true,"tags":[{"type":"param","types":["String"],"name":"token","description":"The token to get the documents for."},{"type":"param","types":["Object"],"name":"root","description":"An optional node at which to start."},{"type":"returns","string":"{Object}"},{"type":"memberOf","parent":"TokenStore"}],"module":false,"parent":"TokenStore","related":{"href":""},"has_related":true},{"id":"69-1397415736691","name":"remove","signiture":"lunr.TokenStore.prototype.remove()","type":"method","ctx":{"type":"method","receiver":"lunr.TokenStore.prototype","name":"remove","string":"lunr.TokenStore.prototype.remove()"},"description":{"full":"<p>Remove the document identified by ref from the token in the store.</p>\n\n<p>By default this function starts at the root of the current store, however<br />it can start at any node of any token store if required.</p>","summary":"<p>Remove the document identified by ref from the token in the store.</p>","body":"<p>By default this function starts at the root of the current store, however<br />it can start at any node of any token store if required.</p>"},"full_description":"<p>Remove the document identified by ref from the token in the store.</p>\n\n<p>By default this function starts at the root of the current store, however it can start at any node of any token store if required.</p>","code":"lunr.TokenStore.prototype.remove = function (token, ref) {\n  if (!token) return\n  var node = this.root\n\n  for (var i = 0; i < token.length; i++) {\n    if (!(token[i] in node)) return\n    node = node[token[i]]\n  }\n\n  delete node.docs[ref]\n}","params":[{"type":"param","types":["String"],"name":"token","description":"The token to get the documents for."},{"type":"param","types":["String"],"name":"ref","description":"The ref of the document to remove from this token."},{"type":"param","types":["Object"],"name":"root","description":"An optional node at which to start."}],"has_params":true,"tags":[{"type":"param","types":["String"],"name":"token","description":"The token to get the documents for."},{"type":"param","types":["String"],"name":"ref","description":"The ref of the document to remove from this token."},{"type":"param","types":["Object"],"name":"root","description":"An optional node at which to start."},{"type":"returns","string":"{Object}"},{"type":"memberOf","parent":"TokenStore"}],"module":false,"parent":"TokenStore","related":{"href":""},"has_related":true},{"id":"70-1397415736691","name":"expand","signiture":"lunr.TokenStore.prototype.expand()","type":"method","ctx":{"type":"method","receiver":"lunr.TokenStore.prototype","name":"expand","string":"lunr.TokenStore.prototype.expand()"},"description":{"full":"<p>Find all the possible suffixes of the passed token using tokens<br />currently in the store.</p>","summary":"<p>Find all the possible suffixes of the passed token using tokens<br />currently in the store.</p>","body":""},"full_description":"<p>Find all the possible suffixes of the passed token using tokens currently in the store.</p>","code":"lunr.TokenStore.prototype.expand = function (token, memo) {\n  var root = this.getNode(token),\n      docs = root.docs || {},\n      memo = memo || []\n\n  if (Object.keys(docs).length) memo.push(token)\n\n  Object.keys(root)\n    .forEach(function (key) {\n      if (key === 'docs') return\n\n      memo.concat(this.expand(token + key, memo))\n    }, this)\n\n  return memo\n}","params":[{"type":"param","types":["String"],"name":"token","description":"The token to expand."}],"has_params":true,"tags":[{"type":"param","types":["String"],"name":"token","description":"The token to expand."},{"type":"returns","string":"{Array}"},{"type":"memberOf","parent":"TokenStore"}],"module":false,"parent":"TokenStore","related":{"href":""},"has_related":true},{"id":"71-1397415736691","name":"toJSON","signiture":"lunr.TokenStore.prototype.toJSON()","type":"method","ctx":{"type":"method","receiver":"lunr.TokenStore.prototype","name":"toJSON","string":"lunr.TokenStore.prototype.toJSON()"},"description":{"full":"<p>Returns a representation of the token store ready for serialisation.</p>","summary":"<p>Returns a representation of the token store ready for serialisation.</p>","body":""},"full_description":"<p>Returns a representation of the token store ready for serialisation.</p>","code":"lunr.TokenStore.prototype.toJSON = function () {\n  return {\n    root: this.root,\n    length: this.length\n  }\n}","params":[],"has_params":false,"tags":[{"type":"returns","string":"{Object}"},{"type":"memberOf","parent":"TokenStore"}],"module":false,"parent":"TokenStore","related":{"href":""},"has_related":true}]}]
  </script>

  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.6.4/jquery.min.js" type="text/javascript" charset="utf-8"></script>

  <script type="text/javascript" charset="utf-8">
    // lunr.js version: 0.0.4
    // (c) 2011 Oliver Nightingale
    //
    //  Released under MIT license.
    //
    var Lunr=function(c,f){var b=new Lunr.Index(c);f.call(b,b);return b};
    Lunr.utils={uniq:function(c){if(!c)return[];return c.reduce(function(c,b){c.indexOf(b)===-1&&c.push(b);return c},[])},intersect:function(c){var f=[].slice.call(arguments,1);return this.uniq(c).filter(function(b){return f.every(function(a){return a.indexOf(b)>=0})})},detect:function(c,f,b){for(var a=c.length,g=null,d=0;d<a;d++)if(f.call(b,c[d],d,c)){g=c[d];break}return g},copy:function(c){return Object.keys(c).reduce(function(f,b){f[b]=c[b];return f},{})}};
    Lunr.Trie=function(){var c=function(){this.children={};this.values=[]};c.prototype={childForKey:function(b){var a=this.children[b];a||(a=new c,this.children[b]=a);return a}};var f=function(){this.root=new c};f.prototype={get:function(b){var a=this;return this.keys(b).reduce(function(c,d){a.getNode(d).values.forEach(function(a){a=Lunr.utils.copy(a);if(b===d)a.exact=!0;c.push(a)});return c},[])},getNode:function(b){var a=function(b,d){if(!d.length)return b;return a(b.childForKey(d.charAt(0)),d.slice(1))};
    return a(this.root,b)},keys:function(b){var a=[];b=b||"";var c=function(b,e){b.values.length&&a.push(e);Object.keys(b.children).forEach(function(a){c(b.children[a],e+a)})};c(this.getNode(b),b);return a},set:function(b,a){var c=function(b,e){if(!e.length)return b.values.push(a);c(b.childForKey(e.charAt(0)),e.slice(1))};return c(this.root,b)}};return f}();Lunr.Index=function(c){this.name=c;this.refName="id";this.fields={};this.trie=new Lunr.Trie};
    Lunr.Index.prototype={add:function(c){(new Lunr.Document(c,this.refName,this.fields)).words().forEach(function(c){this.trie.set(c.id,c.docs[0])},this)},field:function(c,f){this.fields[c]=f||{multiplier:1}},ref:function(c){this.refName=c},search:function(c){if(!c)return[];c=c.split(" ").map(function(c){c=new Lunr.Word(c);if(!c.isStopWord())return c.toString()}).filter(function(c){return c}).map(function(c){return this.trie.get(c).sort(function(b,a){if(b.exact&&a.exact===void 0)return-1;if(a.exact&&
    b.exact===void 0)return 1;if(b.score<a.score)return 1;if(b.score>a.score)return-1;return 0}).map(function(b){return b.documentId})},this);return Lunr.utils.intersect.apply(Lunr.utils,c)}};Lunr.Document=function(c,f,b){this.original=c;this.fields=b;this.ref=c[f]};
    Lunr.Document.prototype={asJSON:function(){return{id:this.ref,words:this.words().map(function(c){return c.id}),original:this.original}},words:function(){var c=this,f={};Object.keys(this.fields).forEach(function(b){c.original[b].split(/\b/g).filter(function(a){return!!a.match(/\w/)}).map(function(a){a=new Lunr.Word(a);if(!a.isStopWord())return a.toString()}).filter(function(a){return a}).forEach(function(a){f[a]||(f[a]={score:0,ref:c.ref});f[a].score+=c.fields[b].multiplier})});return Object.keys(f).map(function(b){return{id:b,
    docs:[{score:f[b].score,documentId:c.ref}]}})}};Lunr.Word=function(c){this.raw=c;this.out=this.raw.replace(/^\W+/,"").replace(/\W+$/,"").toLowerCase()};Lunr.Word.stopWords=["the","of","to","and","a","in","is","it","you","that","this"];
    Lunr.Word.prototype={isStopWord:function(){return Lunr.Word.stopWords.indexOf(this.raw.toLowerCase())!==-1},toString:function(){if(!this.isStopWord())return this.stem(),this.out},stem:function(){var c={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},f={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",
    ful:"",ness:""};return function(){var b,a,g,d=g=this.out;if(g.length<3)return g;var e,h;g=g.substr(0,1);g=="y"&&(d=g.toUpperCase()+d.substr(1));e=/^(.+?)(ss|i)es$/;a=/^(.+?)([^s])s$/;e.test(d)?d=d.replace(e,"$1$2"):a.test(d)&&(d=d.replace(a,"$1$2"));e=/^(.+?)eed$/;a=/^(.+?)(ed|ing)$/;e.test(d)?(a=e.exec(d),e=/^([^aeiou][^aeiouy]*)?[aeiouy][aeiou]*[^aeiou][^aeiouy]*/,e.test(a[1])&&(e=/.$/,d=d.replace(e,""))):a.test(d)&&(a=a.exec(d),b=a[1],a=/^([^aeiou][^aeiouy]*)?[aeiouy]/,a.test(b)&&(d=b,a=/(at|bl|iz)$/,
    h=/([^aeiouylsz])\1$/,b=/^[^aeiou][^aeiouy]*[aeiouy][^aeiouwxy]$/,a.test(d)?d+="e":h.test(d)?(e=/.$/,d=d.replace(e,"")):b.test(d)&&(d+="e")));e=/^(.+?)y$/;e.test(d)&&(a=e.exec(d),b=a[1],e=/^([^aeiou][^aeiouy]*)?[aeiouy]/,e.test(b)&&(d=b+"i"));e=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/;e.test(d)&&(a=e.exec(d),b=a[1],a=a[2],e=/^([^aeiou][^aeiouy]*)?[aeiouy][aeiou]*[^aeiou][^aeiouy]*/,e.test(b)&&(d=b+c[a]));
    e=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/;e.test(d)&&(a=e.exec(d),b=a[1],a=a[2],e=/^([^aeiou][^aeiouy]*)?[aeiouy][aeiou]*[^aeiou][^aeiouy]*/,e.test(b)&&(d=b+f[a]));e=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/;a=/^(.+?)(s|t)(ion)$/;e.test(d)?(a=e.exec(d),b=a[1],e=/^([^aeiou][^aeiouy]*)?[aeiouy][aeiou]*[^aeiou][^aeiouy]*[aeiouy][aeiou]*[^aeiou][^aeiouy]*/,e.test(b)&&(d=b)):a.test(d)&&(a=a.exec(d),b=a[1]+a[2],a=/^([^aeiou][^aeiouy]*)?[aeiouy][aeiou]*[^aeiou][^aeiouy]*[aeiouy][aeiou]*[^aeiou][^aeiouy]*/,
    a.test(b)&&(d=b));e=/^(.+?)e$/;if(e.test(d)&&(a=e.exec(d),b=a[1],e=/^([^aeiou][^aeiouy]*)?[aeiouy][aeiou]*[^aeiou][^aeiouy]*[aeiouy][aeiou]*[^aeiou][^aeiouy]*/,a=/^([^aeiou][^aeiouy]*)?[aeiouy][aeiou]*[^aeiou][^aeiouy]*([aeiouy][aeiou]*)?$/,h=/^[^aeiou][^aeiouy]*[aeiouy][^aeiouwxy]$/,e.test(b)||a.test(b)&&!h.test(b)))d=b;e=/ll$/;a=/^([^aeiou][^aeiouy]*)?[aeiouy][aeiou]*[^aeiou][^aeiouy]*[aeiouy][aeiou]*[^aeiou][^aeiouy]*/;e.test(d)&&a.test(d)&&(e=/.$/,d=d.replace(e,""));g=="y"&&(d=g.toLowerCase()+
    d.substr(1));this.out=d}}()};
  </script>

  <script type="text/javascript" charset="utf-8">
    var idx = Lunr('methods', function () {
      this.ref('id')
      this.field('name', { multiplier: 10 })
      this.field('parent', { multiplier: 5 })
      this.field('full_description')
    })

    var methods = raw.reduce(function (memo, module) {
      return memo.concat(module.methods)
    }, [])

    methods.forEach(function (method) {
      idx.add(method)
    })

    $(document).ready(function () {

      var search = function (term) {
        return idx.search(term).map(function (id) {
          return methods.filter(function (method) {
            return method.id === id
          })[0]
        })
      }

      var searchResults = $('#search-results')

      $('#search-input').keyup(function () {
        var query = $(this).val(),
            results = search(query)

        if (!results.length) {
          searchResults.empty()
          return
        };

        var resultsList = results.reduce(function (ul, result) {
          var li = $('<li>').append($('<a>', {
            href: '#' + result.name,
            text: result.name
          }))

          ul.append(li)

          return ul
        }, $('<ul>'))

        searchResults.html(resultsList)
      })
    })
  </script>

  <style type="text/css" media="screen">
    body {
  font-family: 'Helvetica Neue';
  color: #333;
}

a {
  color: #0f4bf0;
}

header h1 {
  border-top: 4px solid #333;
  font-size: 2.6em;
}

header .version {
  font-size: 0.6em;
}

.main > header {
  margin-bottom: 40px;
}

article {
  margin-bottom: 10px;
  padding-bottom: 30px;
}

article header h2 {
  border-top: 3px solid #333;
  font-size: 2em;
  padding-top: 5px;
}

article > section {
  margin-bottom: 30px;
}

article section h3 {
  font-size: 1em;
}

article section header h3 {
  padding-top: 2px;
  font-size: 1.2em;
  margin-bottom: 5px;
  border-top: 2px solid #333;
}

article section header h4 {
  font-size: 0.9em;
  font-family: courier;
  margin: 2px 0 5px 0;
}

@-webkit-keyframes highlight {
  from {
    background-color: #Ffff66;
  }

  to {
    background-color: white;
  }
}

section.method:target {
  -webkit-animation-duration: 1s;
  -webkit-animation-name: highlight;
}

section header .type, section header .related {
  margin-top: 0px;
  font-size: 0.8em;
}

section.params h4, section.source h4 {
  margin-top: 5px;
  margin-bottom: 2px;
  font-size: 0.9em;
}

section.params ul {
  margin-top: 2px;
}

a.show-source {
  font-size: 0.8em;
}

.wrap {
  width: 960px;
  margin: 0 auto;
}

.main {
  width: 760px;
  float: left;
}

.search {
  margin-top: 10px;
  float: right;
}

#search-input {
  width: 200px;
}

#search-results {
  position: relative;
}

#search-results ul {
  width: 200px;
  position: absolute;
  top: 0px;
  left: 0px;
  background-color: white;
  border: 1px solid #ccc;
  list-style: none;
  padding: 0;
  margin-top: 0;
  font-size: 0.9em;
}

#search-results li {
  padding: 5px;
}

#search-results li:hover {
  background-color: #eee;
  cursor: pointer;
}

#search-results li a {
  text-decoration: none;
  width: 200px;
  display: block;
}

p {
  line-height: 1.4em;
}

nav {
  padding-top: 15px;
  float: left;
  width: 165px;
  margin-right: 30px;
  text-align: right;
  font-size: 0.8em;
}

nav ul {
  list-style: none;
  margin: 0;
  padding: 0;
}

nav ul h3 {
  margin-bottom: 5px;
  border-top: 2px solid #CCC;
  padding-top: 2px;
}

nav ul ul li {
  padding: 2px 0;
}

pre {
  background-color: rgba(0,0,0,0.1);
  padding: 8px;
}

code .keyword, code .special {
  font-weight: bold;
  color: black;
}

code .string, code .regexp {
  color: green
}

code .class { 
  color: blue
}

code .number {
  color: red
}

code .comment {
  color: grey;
  font-style: italic;
}
  </style>
</head>
<body>
  <div class='wrap'>


    <nav>
      <ul>
        
          <li>
            <a href='#lunr'>
              <h3>lunr</h3>
            </a>

            <ul>
              
            </ul>
          </li>
        
          <li>
            <a href='#EventEmitter'>
              <h3>EventEmitter</h3>
            </a>

            <ul>
              
                <li><a href='#addListener'>addListener</a></li>
              
                <li><a href='#removeListener'>removeListener</a></li>
              
                <li><a href='#emit'>emit</a></li>
              
                <li><a href='#hasHandler'>hasHandler</a></li>
              
            </ul>
          </li>
        
          <li>
            <a href='#tokenizer'>
              <h3>tokenizer</h3>
            </a>

            <ul>
              
            </ul>
          </li>
        
          <li>
            <a href='#Pipeline'>
              <h3>Pipeline</h3>
            </a>

            <ul>
              
                <li><a href='#registerFunction'>registerFunction</a></li>
              
                <li><a href='#warnIfFunctionNotRegistered'>warnIfFunctionNotRegistered</a></li>
              
                <li><a href='#load'>load</a></li>
              
                <li><a href='#add'>add</a></li>
              
                <li><a href='#after'>after</a></li>
              
                <li><a href='#before'>before</a></li>
              
                <li><a href='#remove'>remove</a></li>
              
                <li><a href='#run'>run</a></li>
              
                <li><a href='#reset'>reset</a></li>
              
                <li><a href='#toJSON'>toJSON</a></li>
              
            </ul>
          </li>
        
          <li>
            <a href='#Vector'>
              <h3>Vector</h3>
            </a>

            <ul>
              
                <li><a href='#Node'>Node</a></li>
              
                <li><a href='#magnitude'>magnitude</a></li>
              
                <li><a href='#dot'>dot</a></li>
              
                <li><a href='#similarity'>similarity</a></li>
              
            </ul>
          </li>
        
          <li>
            <a href='#Node'>
              <h3>Node</h3>
            </a>

            <ul>
              
            </ul>
          </li>
        
          <li>
            <a href='#SortedSet'>
              <h3>SortedSet</h3>
            </a>

            <ul>
              
                <li><a href='#load'>load</a></li>
              
                <li><a href='#add'>add</a></li>
              
                <li><a href='#toArray'>toArray</a></li>
              
                <li><a href='#map'>map</a></li>
              
                <li><a href='#forEach'>forEach</a></li>
              
                <li><a href='#indexOf'>indexOf</a></li>
              
                <li><a href='#locationFor'>locationFor</a></li>
              
                <li><a href='#intersect'>intersect</a></li>
              
                <li><a href='#clone'>clone</a></li>
              
                <li><a href='#union'>union</a></li>
              
                <li><a href='#toJSON'>toJSON</a></li>
              
            </ul>
          </li>
        
          <li>
            <a href='#Index'>
              <h3>Index</h3>
            </a>

            <ul>
              
                <li><a href='#on'>on</a></li>
              
                <li><a href='#off'>off</a></li>
              
                <li><a href='#load'>load</a></li>
              
                <li><a href='#field'>field</a></li>
              
                <li><a href='#ref'>ref</a></li>
              
                <li><a href='#add'>add</a></li>
              
                <li><a href='#remove'>remove</a></li>
              
                <li><a href='#update'>update</a></li>
              
                <li><a href='#idf'>idf</a></li>
              
                <li><a href='#search'>search</a></li>
              
                <li><a href='#documentVector'>documentVector</a></li>
              
                <li><a href='#toJSON'>toJSON</a></li>
              
                <li><a href='#use'>use</a></li>
              
            </ul>
          </li>
        
          <li>
            <a href='#Store'>
              <h3>Store</h3>
            </a>

            <ul>
              
                <li><a href='#load'>load</a></li>
              
                <li><a href='#set'>set</a></li>
              
                <li><a href='#get'>get</a></li>
              
                <li><a href='#has'>has</a></li>
              
                <li><a href='#remove'>remove</a></li>
              
                <li><a href='#toJSON'>toJSON</a></li>
              
            </ul>
          </li>
        
          <li>
            <a href='#stemmer'>
              <h3>stemmer</h3>
            </a>

            <ul>
              
            </ul>
          </li>
        
          <li>
            <a href='#stopWordFilter'>
              <h3>stopWordFilter</h3>
            </a>

            <ul>
              
            </ul>
          </li>
        
          <li>
            <a href='#trimmer'>
              <h3>trimmer</h3>
            </a>

            <ul>
              
            </ul>
          </li>
        
          <li>
            <a href='#TokenStore'>
              <h3>TokenStore</h3>
            </a>

            <ul>
              
                <li><a href='#load'>load</a></li>
              
                <li><a href='#add'>add</a></li>
              
                <li><a href='#has'>has</a></li>
              
                <li><a href='#getNode'>getNode</a></li>
              
                <li><a href='#get'>get</a></li>
              
                <li><a href='#remove'>remove</a></li>
              
                <li><a href='#expand'>expand</a></li>
              
                <li><a href='#toJSON'>toJSON</a></li>
              
            </ul>
          </li>
        
      </ul>
    </nav>

    <div class='main'>
      <header>
        <div class='search'>
          <input type="search" id="search-input" placeholder="Search"></input>
          <div id="search-results"></div>
        </div>
        <h1>lunr.js <span class='version'>0.5.0</span></h1>
      </header>

      
        <article id='lunr'>
          <header>
            <h2>lunr</h2>
          </header>

          <section>
            <p>Convenience function for instantiating a new lunr index and configuring it with the default pipeline functions and the passed config function.</p>

<p>When using this convenience function a new index will be created with the following functions already in the pipeline:</p>

<p>lunr.StopWordFilter - filters out any stop words before they enter the index</p>

<p>lunr.stemmer - stems the tokens before entering the index.</p>

<p>Example:</p>

<pre><code>var idx = lunr(function () {
  this.field('title', 10)
  this.field('tags', 100)
  this.field('body')

  this.ref('cid')

  this.pipeline.add(function () {
    // some custom pipeline function
  })

})
</code></pre>
          </section>

          
        </article>
      
        <article id='EventEmitter'>
          <header>
            <h2>EventEmitter</h2>
          </header>

          <section>
            <p>lunr.EventEmitter is an event emitter for lunr. It manages adding and removing event handlers and triggering events and their handlers.</p>
          </section>

          
            <section class='method' id='addListener'>
              <header>
                <h3>addListener</h3>
                <h4>lunr.EventEmitter.prototype.addListener()</h4>
                <p class='type'>method</p>
                
                  <p class='related'>See: <a href='#'>addListener</a></p>
                
              </header>

              <section class='params'>
                
                  <h4>Params</h4>
                
                <ul>
                  
                    <li>[eventName] - The name(s) of events to bind this function to.</li>
                  
                    <li>handler - The function to call when an event is fired.</li>
                  
                </ul>
              </section>

              

              <section>
                <p>Binds a handler function to a specific event(s).</p>

<p>Can bind a single function to many different events in one call.</p>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>lunr.EventEmitter.prototype.addListener = function () {
  var args = Array.prototype.slice.call(arguments),
      fn = args.pop(),
      names = args

  if (typeof fn !== &quot;function&quot;) throw new TypeError (&quot;last argument must be a function&quot;)

  names.forEach(function (name) {
    if (!this.hasHandler(name)) this.events[name] = []
    this.events[name].push(fn)
  }, this)
}</code></pre>
              </section>
              
            </section>
          
            <section class='method' id='removeListener'>
              <header>
                <h3>removeListener</h3>
                <h4>lunr.EventEmitter.prototype.removeListener()</h4>
                <p class='type'>method</p>
                
                  <p class='related'>See: <a href='#'>removeListener</a></p>
                
              </header>

              <section class='params'>
                
                  <h4>Params</h4>
                
                <ul>
                  
                    <li>eventName - The name of the event to remove this function from.</li>
                  
                    <li>handler - The function to remove from an event.</li>
                  
                </ul>
              </section>

              

              <section>
                <p>Removes a handler function from a specific event.</p>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>lunr.EventEmitter.prototype.removeListener = function (name, fn) {
  if (!this.hasHandler(name)) return

  var fnIndex = this.events[name].indexOf(fn)
  this.events[name].splice(fnIndex, 1)

  if (!this.events[name].length) delete this.events[name]
}</code></pre>
              </section>
              
            </section>
          
            <section class='method' id='emit'>
              <header>
                <h3>emit</h3>
                <h4>lunr.EventEmitter.prototype.emit()</h4>
                <p class='type'>method</p>
                
                  <p class='related'>See: <a href='#'>emit</a></p>
                
              </header>

              <section class='params'>
                
                  <h4>Params</h4>
                
                <ul>
                  
                    <li>eventName - The name of the event to emit.</li>
                  
                </ul>
              </section>

              

              <section>
                <p>Calls all functions bound to the given event.</p>

<p>Additional data can be passed to the event handler as arguments to <code>emit</code> after the event name.</p>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>lunr.EventEmitter.prototype.emit = function (name) {
  if (!this.hasHandler(name)) return

  var args = Array.prototype.slice.call(arguments, 1)

  this.events[name].forEach(function (fn) {
    fn.apply(undefined, args)
  })
}</code></pre>
              </section>
              
            </section>
          
            <section class='method' id='hasHandler'>
              <header>
                <h3>hasHandler</h3>
                <h4>lunr.EventEmitter.prototype.hasHandler()</h4>
                <p class='type'>method</p>
                
                  <p class='related'>See: <a href='#'>hasHandler</a></p>
                
              </header>

              <section class='params'>
                
                  <h4>Params</h4>
                
                <ul>
                  
                    <li>eventName - The name of the event to check.</li>
                  
                </ul>
              </section>

              

              <section>
                <p>Checks whether a handler has ever been stored against an event.</p>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>lunr.EventEmitter.prototype.hasHandler = function (name) {
  return name in this.events
}</code></pre>
              </section>
              
            </section>
          
        </article>
      
        <article id='tokenizer'>
          <header>
            <h2>tokenizer</h2>
          </header>

          <section>
            <p>A function for splitting a string into tokens ready to be inserted into the search index.</p>
          </section>

          
        </article>
      
        <article id='Pipeline'>
          <header>
            <h2>Pipeline</h2>
          </header>

          <section>
            <p>lunr.Pipelines maintain an ordered list of functions to be applied to all tokens in documents entering the search index and queries being ran against the index.</p>

<p>An instance of lunr.Index created with the lunr shortcut will contain a pipeline with a stop word filter and an English language stemmer. Extra functions can be added before or after either of these functions or these default functions can be removed.</p>

<p>When run the pipeline will call each function in turn, passing a token, the index of that token in the original list of all tokens and finally a list of all the original tokens.</p>

<p>The output of functions in the pipeline will be passed to the next function in the pipeline. To exclude a token from entering the index the function should return undefined, the rest of the pipeline will not be called with this token.</p>

<p>For serialisation of pipelines to work, all functions used in an instance of a pipeline should be registered with lunr.Pipeline. Registered functions can then be loaded. If trying to load a serialised pipeline that uses functions that are not registered an error will be thrown.</p>

<p>If not planning on serialising the pipeline then registering pipeline functions is not necessary.</p>
          </section>

          
            <section class='method' id='registerFunction'>
              <header>
                <h3>registerFunction</h3>
                <h4>lunr.Pipeline.registerFunction()</h4>
                <p class='type'>method</p>
                
                  <p class='related'>See: <a href='#'>registerFunction</a></p>
                
              </header>

              <section class='params'>
                
                  <h4>Params</h4>
                
                <ul>
                  
                    <li>fn - The function to check for.</li>
                  
                    <li>label - The label to register this function with</li>
                  
                </ul>
              </section>

              

              <section>
                <p>Register a function with the pipeline.</p>

<p>Functions that are used in the pipeline should be registered if the pipeline needs to be serialised, or a serialised pipeline needs to be loaded.</p>

<p>Registering a function does not add it to a pipeline, functions must still be added to instances of the pipeline for them to be used when running a pipeline.</p>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>lunr.Pipeline.registerFunction = function (fn, label) {
  if (label in this.registeredFunctions) {
    lunr.utils.warn('Overwriting existing registered function: ' + label)
  }

  fn.label = label
  lunr.Pipeline.registeredFunctions[fn.label] = fn
}</code></pre>
              </section>
              
            </section>
          
            <section class='method' id='warnIfFunctionNotRegistered'>
              <header>
                <h3>warnIfFunctionNotRegistered</h3>
                <h4>lunr.Pipeline.warnIfFunctionNotRegistered()</h4>
                <p class='type'>method</p>
                
                  <p class='related'>See: <a href='#'>warnIfFunctionNotRegistered</a></p>
                
              </header>

              <section class='params'>
                
                  <h4>Params</h4>
                
                <ul>
                  
                    <li>fn - The function to check for.</li>
                  
                </ul>
              </section>

              

              <section>
                <p>Warns if the function is not registered as a Pipeline function.</p>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>lunr.Pipeline.warnIfFunctionNotRegistered = function (fn) {
  var isRegistered = fn.label &amp;&amp; (fn.label in this.registeredFunctions)

  if (!isRegistered) {
    lunr.utils.warn('Function is not registered with pipeline. This may cause problems when serialising the index.\n', fn)
  }
}</code></pre>
              </section>
              
            </section>
          
            <section class='method' id='load'>
              <header>
                <h3>load</h3>
                <h4>lunr.Pipeline.load()</h4>
                <p class='type'>method</p>
                
                  <p class='related'>See: <a href='#'>load</a></p>
                
              </header>

              <section class='params'>
                
                  <h4>Params</h4>
                
                <ul>
                  
                    <li>serialised - The serialised pipeline to load.</li>
                  
                </ul>
              </section>

              

              <section>
                <p>Loads a previously serialised pipeline.</p>

<p>All functions to be loaded must already be registered with lunr.Pipeline. If any function from the serialised data has not been registered then an error will be thrown.</p>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>lunr.Pipeline.load = function (serialised) {
  var pipeline = new lunr.Pipeline

  serialised.forEach(function (fnName) {
    var fn = lunr.Pipeline.registeredFunctions[fnName]

    if (fn) {
      pipeline.add(fn)
    } else {
      throw new Error ('Cannot load un-registered function: ' + fnName)
    }
  })

  return pipeline
}</code></pre>
              </section>
              
            </section>
          
            <section class='method' id='add'>
              <header>
                <h3>add</h3>
                <h4>lunr.Pipeline.prototype.add()</h4>
                <p class='type'>method</p>
                
                  <p class='related'>See: <a href='#'>add</a></p>
                
              </header>

              <section class='params'>
                
                  <h4>Params</h4>
                
                <ul>
                  
                    <li>functions - Any number of functions to add to the pipeline.</li>
                  
                </ul>
              </section>

              

              <section>
                <p>Adds new functions to the end of the pipeline.</p>

<p>Logs a warning if the function has not been registered.</p>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>lunr.Pipeline.prototype.add = function () {
  var fns = Array.prototype.slice.call(arguments)

  fns.forEach(function (fn) {
    lunr.Pipeline.warnIfFunctionNotRegistered(fn)
    this._stack.push(fn)
  }, this)
}</code></pre>
              </section>
              
            </section>
          
            <section class='method' id='after'>
              <header>
                <h3>after</h3>
                <h4>lunr.Pipeline.prototype.after()</h4>
                <p class='type'>method</p>
                
                  <p class='related'>See: <a href='#'>after</a></p>
                
              </header>

              <section class='params'>
                
                  <h4>Params</h4>
                
                <ul>
                  
                    <li>existingFn - A function that already exists in the pipeline.</li>
                  
                    <li>newFn - The new function to add to the pipeline.</li>
                  
                </ul>
              </section>

              

              <section>
                <p>Adds a single function after a function that already exists in the pipeline.</p>

<p>Logs a warning if the function has not been registered.</p>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>lunr.Pipeline.prototype.after = function (existingFn, newFn) {
  lunr.Pipeline.warnIfFunctionNotRegistered(newFn)

  var pos = this._stack.indexOf(existingFn) + 1
  this._stack.splice(pos, 0, newFn)
}</code></pre>
              </section>
              
            </section>
          
            <section class='method' id='before'>
              <header>
                <h3>before</h3>
                <h4>lunr.Pipeline.prototype.before()</h4>
                <p class='type'>method</p>
                
                  <p class='related'>See: <a href='#'>before</a></p>
                
              </header>

              <section class='params'>
                
                  <h4>Params</h4>
                
                <ul>
                  
                    <li>existingFn - A function that already exists in the pipeline.</li>
                  
                    <li>newFn - The new function to add to the pipeline.</li>
                  
                </ul>
              </section>

              

              <section>
                <p>Adds a single function before a function that already exists in the pipeline.</p>

<p>Logs a warning if the function has not been registered.</p>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>lunr.Pipeline.prototype.before = function (existingFn, newFn) {
  lunr.Pipeline.warnIfFunctionNotRegistered(newFn)

  var pos = this._stack.indexOf(existingFn)
  this._stack.splice(pos, 0, newFn)
}</code></pre>
              </section>
              
            </section>
          
            <section class='method' id='remove'>
              <header>
                <h3>remove</h3>
                <h4>lunr.Pipeline.prototype.remove()</h4>
                <p class='type'>method</p>
                
                  <p class='related'>See: <a href='#'>remove</a></p>
                
              </header>

              <section class='params'>
                
                  <h4>Params</h4>
                
                <ul>
                  
                    <li>fn - The function to remove from the pipeline.</li>
                  
                </ul>
              </section>

              

              <section>
                <p>Removes a function from the pipeline.</p>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>lunr.Pipeline.prototype.remove = function (fn) {
  var pos = this._stack.indexOf(fn)
  this._stack.splice(pos, 1)
}</code></pre>
              </section>
              
            </section>
          
            <section class='method' id='run'>
              <header>
                <h3>run</h3>
                <h4>lunr.Pipeline.prototype.run()</h4>
                <p class='type'>method</p>
                
                  <p class='related'>See: <a href='#'>run</a></p>
                
              </header>

              <section class='params'>
                
                  <h4>Params</h4>
                
                <ul>
                  
                    <li>tokens - The tokens to run through the pipeline.</li>
                  
                </ul>
              </section>

              

              <section>
                <p>Runs the current list of functions that make up the pipeline against the passed tokens.</p>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>lunr.Pipeline.prototype.run = function (tokens) {
  var out = [],
      tokenLength = tokens.length,
      stackLength = this._stack.length

  for (var i = 0; i &lt; tokenLength; i++) {
    var token = tokens[i]

    for (var j = 0; j &lt; stackLength; j++) {
      token = this._stack[j](token, i, tokens)
      if (token === void 0) break
    };

    if (token !== void 0) out.push(token)
  };

  return out
}</code></pre>
              </section>
              
            </section>
          
            <section class='method' id='reset'>
              <header>
                <h3>reset</h3>
                <h4>lunr.Pipeline.prototype.reset()</h4>
                <p class='type'>method</p>
                
                  <p class='related'>See: <a href='#'>reset</a></p>
                
              </header>

              <section class='params'>
                
                <ul>
                  
                </ul>
              </section>

              

              <section>
                <p>Resets the pipeline by removing any existing processors.</p>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>lunr.Pipeline.prototype.reset = function () {
  this._stack = []
}</code></pre>
              </section>
              
            </section>
          
            <section class='method' id='toJSON'>
              <header>
                <h3>toJSON</h3>
                <h4>lunr.Pipeline.prototype.toJSON()</h4>
                <p class='type'>method</p>
                
                  <p class='related'>See: <a href='#'>toJSON</a></p>
                
              </header>

              <section class='params'>
                
                <ul>
                  
                </ul>
              </section>

              

              <section>
                <p>Returns a representation of the pipeline ready for serialisation.</p>

<p>Logs a warning if the function has not been registered.</p>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>lunr.Pipeline.prototype.toJSON = function () {
  return this._stack.map(function (fn) {
    lunr.Pipeline.warnIfFunctionNotRegistered(fn)

    return fn.label
  })
}</code></pre>
              </section>
              
            </section>
          
        </article>
      
        <article id='Vector'>
          <header>
            <h2>Vector</h2>
          </header>

          <section>
            <p>lunr.Vectors implement vector related operations for a series of elements.</p>
          </section>

          
            <section class='method' id='Node'>
              <header>
                <h3>Node</h3>
                <h4>lunr.Vector.Node()</h4>
                <p class='type'>method</p>
                
                  <p class='related'>See: <a href='#'>Node</a></p>
                
              </header>

              <section class='params'>
                
                  <h4>Params</h4>
                
                <ul>
                  
                    <li>The - index of the node in the vector.</li>
                  
                    <li>The - data at this node in the vector.</li>
                  
                    <li>The - node directly after this node in the vector.</li>
                  
                </ul>
              </section>

              

              <section>
                <p>lunr.Vector.Node is a simple struct for each node in a lunr.Vector.</p>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>lunr.Vector.Node = function (idx, val, next) {
  this.idx = idx
  this.val = val
  this.next = next
}</code></pre>
              </section>
              
            </section>
          
            <section class='method' id='magnitude'>
              <header>
                <h3>magnitude</h3>
                <h4>lunr.Vector.prototype.magnitude()</h4>
                <p class='type'>method</p>
                
                  <p class='related'>See: <a href='#'>magnitude</a></p>
                
              </header>

              <section class='params'>
                
                <ul>
                  
                </ul>
              </section>

              

              <section>
                <p>Calculates the magnitude of this vector.</p>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>lunr.Vector.prototype.magnitude = function () {
  if (this._magniture) return this._magnitude
  var node = this.list,
      sumOfSquares = 0,
      val

  while (node) {
    val = node.val
    sumOfSquares += val * val
    node = node.next
  }

  return this._magnitude = Math.sqrt(sumOfSquares)
}</code></pre>
              </section>
              
            </section>
          
            <section class='method' id='dot'>
              <header>
                <h3>dot</h3>
                <h4>lunr.Vector.prototype.dot()</h4>
                <p class='type'>method</p>
                
                  <p class='related'>See: <a href='#'>dot</a></p>
                
              </header>

              <section class='params'>
                
                  <h4>Params</h4>
                
                <ul>
                  
                    <li>otherVector - The vector to compute the dot product with.</li>
                  
                </ul>
              </section>

              

              <section>
                <p>Calculates the dot product of this vector and another vector.</p>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>lunr.Vector.prototype.dot = function (otherVector) {
  var node = this.list,
      otherNode = otherVector.list,
      dotProduct = 0

  while (node &amp;&amp; otherNode) {
    if (node.idx &lt; otherNode.idx) {
      node = node.next
    } else if (node.idx &gt; otherNode.idx) {
      otherNode = otherNode.next
    } else {
      dotProduct += node.val * otherNode.val
      node = node.next
      otherNode = otherNode.next
    }
  }

  return dotProduct
}</code></pre>
              </section>
              
            </section>
          
            <section class='method' id='similarity'>
              <header>
                <h3>similarity</h3>
                <h4>lunr.Vector.prototype.similarity()</h4>
                <p class='type'>method</p>
                
                  <p class='related'>See: <a href='#'>similarity</a></p>
                
              </header>

              <section class='params'>
                
                  <h4>Params</h4>
                
                <ul>
                  
                    <li>otherVector - The other vector to calculate the</li>
                  
                </ul>
              </section>

              

              <section>
                <p>Calculates the cosine similarity between this vector and another vector.</p>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>lunr.Vector.prototype.similarity = function (otherVector) {
  return this.dot(otherVector) / (this.magnitude() * otherVector.magnitude())
}</code></pre>
              </section>
              
            </section>
          
        </article>
      
        <article id='Node'>
          <header>
            <h2>Node</h2>
          </header>

          <section>
            <p>lunr.Vector.Node is a simple struct for each node in a lunr.Vector.</p>
          </section>

          
        </article>
      
        <article id='SortedSet'>
          <header>
            <h2>SortedSet</h2>
          </header>

          <section>
            <p>lunr.SortedSets are used to maintain an array of uniq values in a sorted order.</p>
          </section>

          
            <section class='method' id='load'>
              <header>
                <h3>load</h3>
                <h4>lunr.SortedSet.load()</h4>
                <p class='type'>method</p>
                
                  <p class='related'>See: <a href='#'>load</a></p>
                
              </header>

              <section class='params'>
                
                  <h4>Params</h4>
                
                <ul>
                  
                    <li>serialisedData - The serialised set to load.</li>
                  
                </ul>
              </section>

              

              <section>
                <p>Loads a previously serialised sorted set.</p>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>lunr.SortedSet.load = function (serialisedData) {
  var set = new this

  set.elements = serialisedData
  set.length = serialisedData.length

  return set
}</code></pre>
              </section>
              
            </section>
          
            <section class='method' id='add'>
              <header>
                <h3>add</h3>
                <h4>lunr.SortedSet.prototype.add()</h4>
                <p class='type'>method</p>
                
                  <p class='related'>See: <a href='#'>add</a></p>
                
              </header>

              <section class='params'>
                
                  <h4>Params</h4>
                
                <ul>
                  
                    <li>The - objects to add to this set.</li>
                  
                </ul>
              </section>

              

              <section>
                <p>Inserts new items into the set in the correct position to maintain the order.</p>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>lunr.SortedSet.prototype.add = function () {
  Array.prototype.slice.call(arguments).forEach(function (element) {
    if (~this.indexOf(element)) return
    this.elements.splice(this.locationFor(element), 0, element)
  }, this)

  this.length = this.elements.length
}</code></pre>
              </section>
              
            </section>
          
            <section class='method' id='toArray'>
              <header>
                <h3>toArray</h3>
                <h4>lunr.SortedSet.prototype.toArray()</h4>
                <p class='type'>method</p>
                
                  <p class='related'>See: <a href='#'>toArray</a></p>
                
              </header>

              <section class='params'>
                
                <ul>
                  
                </ul>
              </section>

              

              <section>
                <p>Converts this sorted set into an array.</p>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>lunr.SortedSet.prototype.toArray = function () {
  return this.elements.slice()
}</code></pre>
              </section>
              
            </section>
          
            <section class='method' id='map'>
              <header>
                <h3>map</h3>
                <h4>lunr.SortedSet.prototype.map()</h4>
                <p class='type'>method</p>
                
                  <p class='related'>See: <a href='#'>map</a></p>
                
              </header>

              <section class='params'>
                
                  <h4>Params</h4>
                
                <ul>
                  
                    <li>fn - The function that is called on each element of the</li>
                  
                    <li>ctx - An optional object that can be used as the context</li>
                  
                </ul>
              </section>

              

              <section>
                <p>Creates a new array with the results of calling a provided function on every element in this sorted set.</p>

<p>Delegates to Array.prototype.map and has the same signature.</p>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>lunr.SortedSet.prototype.map = function (fn, ctx) {
  return this.elements.map(fn, ctx)
}</code></pre>
              </section>
              
            </section>
          
            <section class='method' id='forEach'>
              <header>
                <h3>forEach</h3>
                <h4>lunr.SortedSet.prototype.forEach()</h4>
                <p class='type'>method</p>
                
                  <p class='related'>See: <a href='#'>forEach</a></p>
                
              </header>

              <section class='params'>
                
                  <h4>Params</h4>
                
                <ul>
                  
                    <li>fn - The function that is called on each element of the</li>
                  
                    <li>ctx - An optional object that can be used as the context</li>
                  
                </ul>
              </section>

              

              <section>
                <p>Executes a provided function once per sorted set element.</p>

<p>Delegates to Array.prototype.forEach and has the same signature.</p>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>lunr.SortedSet.prototype.forEach = function (fn, ctx) {
  return this.elements.forEach(fn, ctx)
}</code></pre>
              </section>
              
            </section>
          
            <section class='method' id='indexOf'>
              <header>
                <h3>indexOf</h3>
                <h4>lunr.SortedSet.prototype.indexOf()</h4>
                <p class='type'>method</p>
                
                  <p class='related'>See: <a href='#'>indexOf</a></p>
                
              </header>

              <section class='params'>
                
                  <h4>Params</h4>
                
                <ul>
                  
                    <li>elem - The object to locate in the sorted set.</li>
                  
                    <li>start - An optional index at which to start searching from</li>
                  
                    <li>end - An optional index at which to stop search from within</li>
                  
                </ul>
              </section>

              

              <section>
                <p>Returns the index at which a given element can be found in the sorted set, or -1 if it is not present.</p>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>lunr.SortedSet.prototype.indexOf = function (elem, start, end) {
  var start = start || 0,
      end = end || this.elements.length,
      sectionLength = end - start,
      pivot = start + Math.floor(sectionLength / 2),
      pivotElem = this.elements[pivot]

  if (sectionLength &lt;= 1) {
    if (pivotElem === elem) {
      return pivot
    } else {
      return -1
    }
  }

  if (pivotElem &lt; elem) return this.indexOf(elem, pivot, end)
  if (pivotElem &gt; elem) return this.indexOf(elem, start, pivot)
  if (pivotElem === elem) return pivot
}</code></pre>
              </section>
              
            </section>
          
            <section class='method' id='locationFor'>
              <header>
                <h3>locationFor</h3>
                <h4>lunr.SortedSet.prototype.locationFor()</h4>
                <p class='type'>method</p>
                
                  <p class='related'>See: <a href='#'>locationFor</a></p>
                
              </header>

              <section class='params'>
                
                  <h4>Params</h4>
                
                <ul>
                  
                    <li>elem - The elem to find the position for in the set</li>
                  
                    <li>start - An optional index at which to start searching from</li>
                  
                    <li>end - An optional index at which to stop search from within</li>
                  
                </ul>
              </section>

              

              <section>
                <p>Returns the position within the sorted set that an element should be inserted at to maintain the current order of the set.</p>

<p>This function assumes that the element to search for does not already exist in the sorted set.</p>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>lunr.SortedSet.prototype.locationFor = function (elem, start, end) {
  var start = start || 0,
      end = end || this.elements.length,
      sectionLength = end - start,
      pivot = start + Math.floor(sectionLength / 2),
      pivotElem = this.elements[pivot]

  if (sectionLength &lt;= 1) {
    if (pivotElem &gt; elem) return pivot
    if (pivotElem &lt; elem) return pivot + 1
  }

  if (pivotElem &lt; elem) return this.locationFor(elem, pivot, end)
  if (pivotElem &gt; elem) return this.locationFor(elem, start, pivot)
}</code></pre>
              </section>
              
            </section>
          
            <section class='method' id='intersect'>
              <header>
                <h3>intersect</h3>
                <h4>lunr.SortedSet.prototype.intersect()</h4>
                <p class='type'>method</p>
                
                  <p class='related'>See: <a href='#'>intersect</a></p>
                
              </header>

              <section class='params'>
                
                  <h4>Params</h4>
                
                <ul>
                  
                    <li>otherSet - The set to intersect with this set.</li>
                  
                </ul>
              </section>

              

              <section>
                <p>Creates a new lunr.SortedSet that contains the elements in the intersection of this set and the passed set.</p>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>lunr.SortedSet.prototype.intersect = function (otherSet) {
  var intersectSet = new lunr.SortedSet,
      i = 0, j = 0,
      a_len = this.length, b_len = otherSet.length,
      a = this.elements, b = otherSet.elements

  while (true) {
    if (i &gt; a_len - 1 || j &gt; b_len - 1) break

    if (a[i] === b[j]) {
      intersectSet.add(a[i])
      i++, j++
      continue
    }

    if (a[i] &lt; b[j]) {
      i++
      continue
    }

    if (a[i] &gt; b[j]) {
      j++
      continue
    }
  };

  return intersectSet
}</code></pre>
              </section>
              
            </section>
          
            <section class='method' id='clone'>
              <header>
                <h3>clone</h3>
                <h4>lunr.SortedSet.prototype.clone()</h4>
                <p class='type'>method</p>
                
                  <p class='related'>See: <a href='#'>clone</a></p>
                
              </header>

              <section class='params'>
                
                <ul>
                  
                </ul>
              </section>

              

              <section>
                <p>Makes a copy of this set</p>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>lunr.SortedSet.prototype.clone = function () {
  var clone = new lunr.SortedSet

  clone.elements = this.toArray()
  clone.length = clone.elements.length

  return clone
}</code></pre>
              </section>
              
            </section>
          
            <section class='method' id='union'>
              <header>
                <h3>union</h3>
                <h4>lunr.SortedSet.prototype.union()</h4>
                <p class='type'>method</p>
                
                  <p class='related'>See: <a href='#'>union</a></p>
                
              </header>

              <section class='params'>
                
                  <h4>Params</h4>
                
                <ul>
                  
                    <li>otherSet - The set to union with this set.</li>
                  
                </ul>
              </section>

              

              <section>
                <p>Creates a new lunr.SortedSet that contains the elements in the union of this set and the passed set.</p>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>lunr.SortedSet.prototype.union = function (otherSet) {
  var longSet, shortSet, unionSet

  if (this.length &gt;= otherSet.length) {
    longSet = this, shortSet = otherSet
  } else {
    longSet = otherSet, shortSet = this
  }

  unionSet = longSet.clone()

  unionSet.add.apply(unionSet, shortSet.toArray())

  return unionSet
}</code></pre>
              </section>
              
            </section>
          
            <section class='method' id='toJSON'>
              <header>
                <h3>toJSON</h3>
                <h4>lunr.SortedSet.prototype.toJSON()</h4>
                <p class='type'>method</p>
                
                  <p class='related'>See: <a href='#'>toJSON</a></p>
                
              </header>

              <section class='params'>
                
                <ul>
                  
                </ul>
              </section>

              

              <section>
                <p>Returns a representation of the sorted set ready for serialisation.</p>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>lunr.SortedSet.prototype.toJSON = function () {
  return this.toArray()
}</code></pre>
              </section>
              
            </section>
          
        </article>
      
        <article id='Index'>
          <header>
            <h2>Index</h2>
          </header>

          <section>
            <p>lunr.Index is object that manages a search index.  It contains the indexes and stores all the tokens and document lookups.  It also provides the main user facing API for the library.</p>
          </section>

          
            <section class='method' id='on'>
              <header>
                <h3>on</h3>
                <h4>lunr.Index.prototype.on()</h4>
                <p class='type'>method</p>
                
                  <p class='related'>See: <a href='#'>on</a></p>
                
              </header>

              <section class='params'>
                
                  <h4>Params</h4>
                
                <ul>
                  
                    <li>[eventName] - The name(s) of events to bind the function to.</li>
                  
                    <li>handler - The serialised set to load.</li>
                  
                </ul>
              </section>

              

              <section>
                <p>Bind a handler to events being emitted by the index.</p>

<p>The handler can be bound to many events at the same time.</p>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>lunr.Index.prototype.on = function () {
  var args = Array.prototype.slice.call(arguments)
  return this.eventEmitter.addListener.apply(this.eventEmitter, args)
}</code></pre>
              </section>
              
            </section>
          
            <section class='method' id='off'>
              <header>
                <h3>off</h3>
                <h4>lunr.Index.prototype.off()</h4>
                <p class='type'>method</p>
                
                  <p class='related'>See: <a href='#'>off</a></p>
                
              </header>

              <section class='params'>
                
                  <h4>Params</h4>
                
                <ul>
                  
                    <li>eventName - The name of events to remove the function from.</li>
                  
                    <li>handler - The serialised set to load.</li>
                  
                </ul>
              </section>

              

              <section>
                <p>Removes a handler from an event being emitted by the index.</p>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>lunr.Index.prototype.off = function (name, fn) {
  return this.eventEmitter.removeListener(name, fn)
}</code></pre>
              </section>
              
            </section>
          
            <section class='method' id='load'>
              <header>
                <h3>load</h3>
                <h4>lunr.Index.load()</h4>
                <p class='type'>method</p>
                
                  <p class='related'>See: <a href='#'>load</a></p>
                
              </header>

              <section class='params'>
                
                  <h4>Params</h4>
                
                <ul>
                  
                    <li>serialisedData - The serialised set to load.</li>
                  
                </ul>
              </section>

              

              <section>
                <p>Loads a previously serialised index.</p>

<p>Issues a warning if the index being imported was serialised by a different version of lunr.</p>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>lunr.Index.load = function (serialisedData) {
  if (serialisedData.version !== lunr.version) {
    lunr.utils.warn('version mismatch: current ' + lunr.version + ' importing ' + serialisedData.version)
  }

  var idx = new this

  idx._fields = serialisedData.fields
  idx._ref = serialisedData.ref

  idx.documentStore = lunr.Store.load(serialisedData.documentStore)
  idx.tokenStore = lunr.TokenStore.load(serialisedData.tokenStore)
  idx.corpusTokens = lunr.SortedSet.load(serialisedData.corpusTokens)
  idx.indexPipeline = lunr.Pipeline.load(serialisedData.indexPipeline)
  idx.searchPipeline = lunr.Pipeline.load(serialisedData.searchPipeline)

  return idx
}</code></pre>
              </section>
              
            </section>
          
            <section class='method' id='field'>
              <header>
                <h3>field</h3>
                <h4>lunr.Index.prototype.field()</h4>
                <p class='type'>method</p>
                
                  <p class='related'>See: <a href='#'>field</a></p>
                
              </header>

              <section class='params'>
                
                  <h4>Params</h4>
                
                <ul>
                  
                    <li>fieldName - The name of the field within the document that</li>
                  
                    <li>boost - An optional boost that can be applied to terms in this</li>
                  
                </ul>
              </section>

              

              <section>
                <p>Adds a field to the list of fields that will be searchable within documents in the index.</p>

<p>An optional boost param can be passed to affect how much tokens in this field rank in search results, by default the boost value is 1.</p>

<p>Fields should be added before any documents are added to the index, fields that are added after documents are added to the index will only apply to new documents added to the index.</p>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>lunr.Index.prototype.field = function (fieldName, opts) {
  var opts = opts || {},
      field = { name: fieldName, boost: opts.boost || 1 }

  this._fields.push(field)
  return this
}</code></pre>
              </section>
              
            </section>
          
            <section class='method' id='ref'>
              <header>
                <h3>ref</h3>
                <h4>lunr.Index.prototype.ref()</h4>
                <p class='type'>method</p>
                
                  <p class='related'>See: <a href='#'>ref</a></p>
                
              </header>

              <section class='params'>
                
                  <h4>Params</h4>
                
                <ul>
                  
                    <li>refName - The property to use to uniquely identify the</li>
                  
                    <li>emitEvent - Whether to emit add events, defaults to true</li>
                  
                </ul>
              </section>

              

              <section>
                <p>Sets the property used to uniquely identify documents added to the index, by default this property is 'id'.</p>

<p>This should only be changed before adding documents to the index, changing the ref property without resetting the index can lead to unexpected results.</p>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>lunr.Index.prototype.ref = function (refName) {
  this._ref = refName
  return this
}</code></pre>
              </section>
              
            </section>
          
            <section class='method' id='add'>
              <header>
                <h3>add</h3>
                <h4>lunr.Index.prototype.add()</h4>
                <p class='type'>method</p>
                
                  <p class='related'>See: <a href='#'>add</a></p>
                
              </header>

              <section class='params'>
                
                  <h4>Params</h4>
                
                <ul>
                  
                    <li>doc - The document to add to the index.</li>
                  
                    <li>emitEvent - Whether or not to emit events, default true.</li>
                  
                </ul>
              </section>

              

              <section>
                <p>Add a document to the index.</p>

<p>This is the way new documents enter the index, this function will run the fields from the document through the index's pipeline and then add it to the index, it will then show up in search results.</p>

<p>An 'add' event is emitted with the document that has been added and the index the document has been added to. This event can be silenced by passing false as the second argument to add.</p>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>lunr.Index.prototype.add = function (doc, emitEvent) {
  var docTokens = {},
      allDocumentTokens = new lunr.SortedSet,
      docRef = doc[this._ref],
      emitEvent = emitEvent === undefined ? true : emitEvent

  this._fields.forEach(function (field) {
    var fieldTokens = this.indexPipeline.run(lunr.tokenizer(doc[field.name]))

    docTokens[field.name] = fieldTokens
    lunr.SortedSet.prototype.add.apply(allDocumentTokens, fieldTokens)
  }, this)

  this.documentStore.set(docRef, allDocumentTokens)
  lunr.SortedSet.prototype.add.apply(this.corpusTokens, allDocumentTokens.toArray())

  for (var i = 0; i &lt; allDocumentTokens.length; i++) {
    var token = allDocumentTokens.elements[i]
    var tf = this._fields.reduce(function (memo, field) {
      var fieldLength = docTokens[field.name].length

      if (!fieldLength) return memo

      var tokenCount = docTokens[field.name].filter(function (t) { return t === token }).length

      return memo + (tokenCount / fieldLength * field.boost)
    }, 0)

    this.tokenStore.add(token, { ref: docRef, tf: tf })
  };

  if (emitEvent) this.eventEmitter.emit('add', doc, this)
}</code></pre>
              </section>
              
            </section>
          
            <section class='method' id='remove'>
              <header>
                <h3>remove</h3>
                <h4>lunr.Index.prototype.remove()</h4>
                <p class='type'>method</p>
                
                  <p class='related'>See: <a href='#'>remove</a></p>
                
              </header>

              <section class='params'>
                
                  <h4>Params</h4>
                
                <ul>
                  
                    <li>doc - The document to remove from the index.</li>
                  
                    <li>emitEvent - Whether to emit remove events, defaults to true</li>
                  
                </ul>
              </section>

              

              <section>
                <p>Removes a document from the index.</p>

<p>To make sure documents no longer show up in search results they can be removed from the index using this method.</p>

<p>The document passed only needs to have the same ref property value as the document that was added to the index, they could be completely different objects.</p>

<p>A 'remove' event is emitted with the document that has been removed and the index the document has been removed from. This event can be silenced by passing false as the second argument to remove.</p>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>lunr.Index.prototype.remove = function (doc, emitEvent) {
  var docRef = doc[this._ref],
      emitEvent = emitEvent === undefined ? true : emitEvent

  if (!this.documentStore.has(docRef)) return

  var docTokens = this.documentStore.get(docRef)

  this.documentStore.remove(docRef)

  docTokens.forEach(function (token) {
    this.tokenStore.remove(token, docRef)
  }, this)

  if (emitEvent) this.eventEmitter.emit('remove', doc, this)
}</code></pre>
              </section>
              
            </section>
          
            <section class='method' id='update'>
              <header>
                <h3>update</h3>
                <h4>lunr.Index.prototype.update()</h4>
                <p class='type'>method</p>
                
                  <p class='related'>See: <a href='#'>update</a></p>
                
              </header>

              <section class='params'>
                
                  <h4>Params</h4>
                
                <ul>
                  
                    <li>doc - The document to update in the index.</li>
                  
                    <li>emitEvent - Whether to emit update events, defaults to true</li>
                  
                </ul>
              </section>

              

              <section>
                <p>Updates a document in the index.</p>

<p>When a document contained within the index gets updated, fields changed, added or removed, to make sure it correctly matched against search queries, it should be updated in the index.</p>

<p>This method is just a wrapper around <code>remove</code> and <code>add</code></p>

<p>An 'update' event is emitted with the document that has been updated and the index. This event can be silenced by passing false as the second argument to update. Only an update event will be fired, the 'add' and 'remove' events of the underlying calls are silenced.</p>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>lunr.Index.prototype.update = function (doc, emitEvent) {
  var emitEvent = emitEvent === undefined ? true : emitEvent

  this.remove(doc, false)
  this.add(doc, false)

  if (emitEvent) this.eventEmitter.emit('update', doc, this)
}</code></pre>
              </section>
              
            </section>
          
            <section class='method' id='idf'>
              <header>
                <h3>idf</h3>
                <h4>lunr.Index.prototype.idf()</h4>
                <p class='type'>method</p>
                
                  <p class='related'>See: <a href='#'>idf</a></p>
                
              </header>

              <section class='params'>
                
                  <h4>Params</h4>
                
                <ul>
                  
                    <li>token - The token to calculate the idf of.</li>
                  
                </ul>
              </section>

              

              <section>
                <p>Calculates the inverse document frequency for a token within the index.</p>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>lunr.Index.prototype.idf = function (term) {
  var cacheKey = &quot;@&quot; + term
  if (Object.prototype.hasOwnProperty.call(this._idfCache, cacheKey)) return this._idfCache[cacheKey]

  var documentFrequency = this.tokenStore.count(term),
      idf = 1

  if (documentFrequency &gt; 0) {
    idf = 1 + Math.log(this.tokenStore.length / documentFrequency)
  }

  return this._idfCache[cacheKey] = idf
}</code></pre>
              </section>
              
            </section>
          
            <section class='method' id='search'>
              <header>
                <h3>search</h3>
                <h4>lunr.Index.prototype.search()</h4>
                <p class='type'>method</p>
                
                  <p class='related'>See: <a href='#'>search</a></p>
                
              </header>

              <section class='params'>
                
                  <h4>Params</h4>
                
                <ul>
                  
                    <li>query - The query to search the index with.</li>
                  
                </ul>
              </section>

              

              <section>
                <p>Searches the index using the passed query.</p>

<p>Queries should be a string, multiple words are allowed and will lead to an AND based query, e.g. <code>idx.search('foo bar')</code> will run a search for documents containing both 'foo' and 'bar'.</p>

<p>All query tokens are passed through the same pipeline that document tokens are passed through, so any language processing involved will be run on every query term.</p>

<p>Each query term is expanded, so that the term 'he' might be expanded to 'hello' and 'help' if those terms were already included in the index.</p>

<p>Matching documents are returned as an array of objects, each object contains the matching document ref, as set for this index, and the similarity score for this document against the query.</p>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>lunr.Index.prototype.search = function (query) {
  var queryTokens = this.searchPipeline.run(lunr.tokenizer(query)),
      queryVector = new lunr.Vector,
      documentSets = [],
      fieldBoosts = this._fields.reduce(function (memo, f) { return memo + f.boost }, 0)

  var hasSomeToken = queryTokens.some(function (token) {
    return this.tokenStore.has(token)
  }, this)

  if (!hasSomeToken) return []

  queryTokens
    .forEach(function (token, i, tokens) {
      var tf = 1 / tokens.length * this._fields.length * fieldBoosts,
          self = this

      var set = this.tokenStore.expand(token).reduce(function (memo, key) {
        var pos = self.corpusTokens.indexOf(key),
            idf = self.idf(key),
            similarityBoost = 1,
            set = new lunr.SortedSet

        // if the expanded key is not an exact match to the token then
        // penalise the score for this key by how different the key is
        // to the token.
        if (key !== token) {
          var diff = Math.max(3, key.length - token.length)
          similarityBoost = 1 / Math.log(diff)
        }

        // calculate the query tf-idf score for this token
        // applying an similarityBoost to ensure exact matches
        // these rank higher than expanded terms
        if (pos &gt; -1) queryVector.insert(pos, tf * idf * similarityBoost)

        // add all the documents that have this key into a set
        Object.keys(self.tokenStore.get(key)).forEach(function (ref) { set.add(ref) })

        return memo.union(set)
      }, new lunr.SortedSet)

      documentSets.push(set)
    }, this)

  var documentSet = documentSets.reduce(function (memo, set) {
    return memo.intersect(set)
  })

  return documentSet
    .map(function (ref) {
      return { ref: ref, score: queryVector.similarity(this.documentVector(ref)) }
    }, this)
    .sort(function (a, b) {
      return b.score - a.score
    })
}</code></pre>
              </section>
              
            </section>
          
            <section class='method' id='documentVector'>
              <header>
                <h3>documentVector</h3>
                <h4>lunr.Index.prototype.documentVector()</h4>
                <p class='type'>method</p>
                
                  <p class='related'>See: <a href='#'>documentVector</a></p>
                
              </header>

              <section class='params'>
                
                  <h4>Params</h4>
                
                <ul>
                  
                    <li>documentRef - The ref to find the document with.</li>
                  
                </ul>
              </section>

              

              <section>
                <p>Generates a vector containing all the tokens in the document matching the passed documentRef.</p>

<p>The vector contains the tf-idf score for each token contained in the document with the passed documentRef.  The vector will contain an element for every token in the indexes corpus, if the document does not contain that token the element will be 0.</p>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>lunr.Index.prototype.documentVector = function (documentRef) {
  var documentTokens = this.documentStore.get(documentRef),
      documentTokensLength = documentTokens.length,
      documentVector = new lunr.Vector

  for (var i = 0; i &lt; documentTokensLength; i++) {
    var token = documentTokens.elements[i],
        tf = this.tokenStore.get(token)[documentRef].tf,
        idf = this.idf(token)

    documentVector.insert(this.corpusTokens.indexOf(token), tf * idf)
  };

  return documentVector
}</code></pre>
              </section>
              
            </section>
          
            <section class='method' id='toJSON'>
              <header>
                <h3>toJSON</h3>
                <h4>lunr.Index.prototype.toJSON()</h4>
                <p class='type'>method</p>
                
                  <p class='related'>See: <a href='#'>toJSON</a></p>
                
              </header>

              <section class='params'>
                
                <ul>
                  
                </ul>
              </section>

              

              <section>
                <p>Returns a representation of the index ready for serialisation.</p>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>lunr.Index.prototype.toJSON = function () {
  return {
    version: lunr.version,
    fields: this._fields,
    ref: this._ref,
    documentStore: this.documentStore.toJSON(),
    tokenStore: this.tokenStore.toJSON(),
    corpusTokens: this.corpusTokens.toJSON(),
    indexPipeline: this.indexPipeline.toJSON(),
    searchPipeline: this.searchPipeline.toJSON()
  }
}</code></pre>
              </section>
              
            </section>
          
            <section class='method' id='use'>
              <header>
                <h3>use</h3>
                <h4>lunr.Index.prototype.use()</h4>
                <p class='type'>method</p>
                
                  <p class='related'>See: <a href='#'>use</a></p>
                
              </header>

              <section class='params'>
                
                  <h4>Params</h4>
                
                <ul>
                  
                    <li>plugin - The plugin to apply.</li>
                  
                </ul>
              </section>

              

              <section>
                <p>Applies a plugin to the current index.</p>

<p>A plugin is a function that is called with the index as its context. Plugins can be used to customise or extend the behaviour the index in some way. A plugin is just a function, that encapsulated the custom behaviour that should be applied to the index.</p>

<p>The plugin function will be called with the index as its argument, additional arguments can also be passed when calling use. The function will be called with the index as its context.</p>

<p>Example:</p>

<pre><code>var myPlugin = function (idx, arg1, arg2) {
  // `this` is the index to be extended
  // apply any extensions etc here.
}

var idx = lunr(function () {
  this.use(myPlugin, 'arg1', 'arg2')
})
</code></pre>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>lunr.Index.prototype.use = function (plugin) {
  var args = Array.prototype.slice.call(arguments, 1)
  args.unshift(this)
  plugin.apply(this, args)
}</code></pre>
              </section>
              
            </section>
          
        </article>
      
        <article id='Store'>
          <header>
            <h2>Store</h2>
          </header>

          <section>
            <p>lunr.Store is a simple key-value store used for storing sets of tokens for documents stored in index.</p>
          </section>

          
            <section class='method' id='load'>
              <header>
                <h3>load</h3>
                <h4>lunr.Store.load()</h4>
                <p class='type'>method</p>
                
                  <p class='related'>See: <a href='#'>load</a></p>
                
              </header>

              <section class='params'>
                
                  <h4>Params</h4>
                
                <ul>
                  
                    <li>serialisedData - The serialised store to load.</li>
                  
                </ul>
              </section>

              

              <section>
                <p>Loads a previously serialised store</p>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>lunr.Store.load = function (serialisedData) {
  var store = new this

  store.length = serialisedData.length
  store.store = Object.keys(serialisedData.store).reduce(function (memo, key) {
    memo[key] = lunr.SortedSet.load(serialisedData.store[key])
    return memo
  }, {})

  return store
}</code></pre>
              </section>
              
            </section>
          
            <section class='method' id='set'>
              <header>
                <h3>set</h3>
                <h4>lunr.Store.prototype.set()</h4>
                <p class='type'>method</p>
                
                  <p class='related'>See: <a href='#'>set</a></p>
                
              </header>

              <section class='params'>
                
                  <h4>Params</h4>
                
                <ul>
                  
                    <li>id - The key used to store the tokens against.</li>
                  
                    <li>tokens - The tokens to store against the key.</li>
                  
                </ul>
              </section>

              

              <section>
                <p>Stores the given tokens in the store against the given id.</p>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>lunr.Store.prototype.set = function (id, tokens) {
  this.store[id] = tokens
  this.length = Object.keys(this.store).length
}</code></pre>
              </section>
              
            </section>
          
            <section class='method' id='get'>
              <header>
                <h3>get</h3>
                <h4>lunr.Store.prototype.get()</h4>
                <p class='type'>method</p>
                
                  <p class='related'>See: <a href='#'>get</a></p>
                
              </header>

              <section class='params'>
                
                  <h4>Params</h4>
                
                <ul>
                  
                    <li>id - The key to lookup and retrieve from the store.</li>
                  
                </ul>
              </section>

              

              <section>
                <p>Retrieves the tokens from the store for a given key.</p>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>lunr.Store.prototype.get = function (id) {
  return this.store[id]
}</code></pre>
              </section>
              
            </section>
          
            <section class='method' id='has'>
              <header>
                <h3>has</h3>
                <h4>lunr.Store.prototype.has()</h4>
                <p class='type'>method</p>
                
                  <p class='related'>See: <a href='#'>has</a></p>
                
              </header>

              <section class='params'>
                
                  <h4>Params</h4>
                
                <ul>
                  
                    <li>id - The id to look up in the store.</li>
                  
                </ul>
              </section>

              

              <section>
                <p>Checks whether the store contains a key.</p>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>lunr.Store.prototype.has = function (id) {
  return id in this.store
}</code></pre>
              </section>
              
            </section>
          
            <section class='method' id='remove'>
              <header>
                <h3>remove</h3>
                <h4>lunr.Store.prototype.remove()</h4>
                <p class='type'>method</p>
                
                  <p class='related'>See: <a href='#'>remove</a></p>
                
              </header>

              <section class='params'>
                
                  <h4>Params</h4>
                
                <ul>
                  
                    <li>id - The id to remove from the store.</li>
                  
                </ul>
              </section>

              

              <section>
                <p>Removes the value for a key in the store.</p>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>lunr.Store.prototype.remove = function (id) {
  if (!this.has(id)) return

  delete this.store[id]
  this.length--
}</code></pre>
              </section>
              
            </section>
          
            <section class='method' id='toJSON'>
              <header>
                <h3>toJSON</h3>
                <h4>lunr.Store.prototype.toJSON()</h4>
                <p class='type'>method</p>
                
                  <p class='related'>See: <a href='#'>toJSON</a></p>
                
              </header>

              <section class='params'>
                
                <ul>
                  
                </ul>
              </section>

              

              <section>
                <p>Returns a representation of the store ready for serialisation.</p>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>lunr.Store.prototype.toJSON = function () {
  return {
    store: this.store,
    length: this.length
  }
}</code></pre>
              </section>
              
            </section>
          
        </article>
      
        <article id='stemmer'>
          <header>
            <h2>stemmer</h2>
          </header>

          <section>
            <p>lunr.stemmer is an english language stemmer, this is a JavaScript implementation of the PorterStemmer taken from <a href='http://tartaurs.org/~martin'>http://tartaurs.org/~martin</a></p>
          </section>

          
        </article>
      
        <article id='stopWordFilter'>
          <header>
            <h2>stopWordFilter</h2>
          </header>

          <section>
            <p>lunr.stopWordFilter is an English language stop word list filter, any words contained in the list will not be passed through the filter.</p>

<p>This is intended to be used in the Pipeline. If the token does not pass the filter then undefined will be returned.</p>
          </section>

          
        </article>
      
        <article id='trimmer'>
          <header>
            <h2>trimmer</h2>
          </header>

          <section>
            <p>lunr.trimmer is a pipeline function for trimming non word characters from the begining and end of tokens before they enter the index.</p>

<p>This implementation may not work correctly for non latin characters and should either be removed or adapted for use with languages with non-latin characters.</p>
          </section>

          
        </article>
      
        <article id='TokenStore'>
          <header>
            <h2>TokenStore</h2>
          </header>

          <section>
            <p>lunr.TokenStore is used for efficient storing and lookup of the reverse index of token to document ref.</p>
          </section>

          
            <section class='method' id='load'>
              <header>
                <h3>load</h3>
                <h4>lunr.TokenStore.load()</h4>
                <p class='type'>method</p>
                
                  <p class='related'>See: <a href='#'>load</a></p>
                
              </header>

              <section class='params'>
                
                  <h4>Params</h4>
                
                <ul>
                  
                    <li>serialisedData - The serialised token store to load.</li>
                  
                </ul>
              </section>

              

              <section>
                <p>Loads a previously serialised token store</p>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>lunr.TokenStore.load = function (serialisedData) {
  var store = new this

  store.root = serialisedData.root
  store.length = serialisedData.length

  return store
}</code></pre>
              </section>
              
            </section>
          
            <section class='method' id='add'>
              <header>
                <h3>add</h3>
                <h4>lunr.TokenStore.prototype.add()</h4>
                <p class='type'>method</p>
                
                  <p class='related'>See: <a href='#'>add</a></p>
                
              </header>

              <section class='params'>
                
                  <h4>Params</h4>
                
                <ul>
                  
                    <li>token - The token to store the doc under</li>
                  
                    <li>doc - The doc to store against the token</li>
                  
                    <li>root - An optional node at which to start looking for the</li>
                  
                </ul>
              </section>

              

              <section>
                <p>Adds a new token doc pair to the store.</p>

<p>By default this function starts at the root of the current store, however it can start at any node of any token store if required.</p>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>lunr.TokenStore.prototype.add = function (token, doc, root) {
  var root = root || this.root,
      key = token[0],
      rest = token.slice(1)

  if (!(key in root)) root[key] = {docs: {}}

  if (rest.length === 0) {
    root[key].docs[doc.ref] = doc
    this.length += 1
    return
  } else {
    return this.add(rest, doc, root[key])
  }
}</code></pre>
              </section>
              
            </section>
          
            <section class='method' id='has'>
              <header>
                <h3>has</h3>
                <h4>lunr.TokenStore.prototype.has()</h4>
                <p class='type'>method</p>
                
                  <p class='related'>See: <a href='#'>has</a></p>
                
              </header>

              <section class='params'>
                
                  <h4>Params</h4>
                
                <ul>
                  
                    <li>token - The token to check for</li>
                  
                    <li>root - An optional node at which to start</li>
                  
                </ul>
              </section>

              

              <section>
                <p>Checks whether this key is contained within this lunr.TokenStore.</p>

<p>By default this function starts at the root of the current store, however it can start at any node of any token store if required.</p>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>lunr.TokenStore.prototype.has = function (token) {
  if (!token) return false

  var node = this.root

  for (var i = 0; i &lt; token.length; i++) {
    if (!node[token[i]]) return false

    node = node[token[i]]
  }

  return true
}</code></pre>
              </section>
              
            </section>
          
            <section class='method' id='getNode'>
              <header>
                <h3>getNode</h3>
                <h4>lunr.TokenStore.prototype.getNode()</h4>
                <p class='type'>method</p>
                
                  <p class='related'>See: <a href='#'>getNode</a></p>
                
              </header>

              <section class='params'>
                
                  <h4>Params</h4>
                
                <ul>
                  
                    <li>token - The token to get the node for.</li>
                  
                    <li>root - An optional node at which to start.</li>
                  
                </ul>
              </section>

              

              <section>
                <p>Retrieve a node from the token store for a given token.</p>

<p>By default this function starts at the root of the current store, however it can start at any node of any token store if required.</p>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>lunr.TokenStore.prototype.getNode = function (token) {
  if (!token) return {}

  var node = this.root

  for (var i = 0; i &lt; token.length; i++) {
    if (!node[token[i]]) return {}

    node = node[token[i]]
  }

  return node
}</code></pre>
              </section>
              
            </section>
          
            <section class='method' id='get'>
              <header>
                <h3>get</h3>
                <h4>lunr.TokenStore.prototype.get()</h4>
                <p class='type'>method</p>
                
                  <p class='related'>See: <a href='#'>get</a></p>
                
              </header>

              <section class='params'>
                
                  <h4>Params</h4>
                
                <ul>
                  
                    <li>token - The token to get the documents for.</li>
                  
                    <li>root - An optional node at which to start.</li>
                  
                </ul>
              </section>

              

              <section>
                <p>Retrieve the documents for a node for the given token.</p>

<p>By default this function starts at the root of the current store, however it can start at any node of any token store if required.</p>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>lunr.TokenStore.prototype.get = function (token, root) {
  return this.getNode(token, root).docs || {}
}

lunr.TokenStore.prototype.count = function (token, root) {
  return Object.keys(this.get(token, root)).length
}</code></pre>
              </section>
              
            </section>
          
            <section class='method' id='remove'>
              <header>
                <h3>remove</h3>
                <h4>lunr.TokenStore.prototype.remove()</h4>
                <p class='type'>method</p>
                
                  <p class='related'>See: <a href='#'>remove</a></p>
                
              </header>

              <section class='params'>
                
                  <h4>Params</h4>
                
                <ul>
                  
                    <li>token - The token to get the documents for.</li>
                  
                    <li>ref - The ref of the document to remove from this token.</li>
                  
                    <li>root - An optional node at which to start.</li>
                  
                </ul>
              </section>

              

              <section>
                <p>Remove the document identified by ref from the token in the store.</p>

<p>By default this function starts at the root of the current store, however it can start at any node of any token store if required.</p>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>lunr.TokenStore.prototype.remove = function (token, ref) {
  if (!token) return
  var node = this.root

  for (var i = 0; i &lt; token.length; i++) {
    if (!(token[i] in node)) return
    node = node[token[i]]
  }

  delete node.docs[ref]
}</code></pre>
              </section>
              
            </section>
          
            <section class='method' id='expand'>
              <header>
                <h3>expand</h3>
                <h4>lunr.TokenStore.prototype.expand()</h4>
                <p class='type'>method</p>
                
                  <p class='related'>See: <a href='#'>expand</a></p>
                
              </header>

              <section class='params'>
                
                  <h4>Params</h4>
                
                <ul>
                  
                    <li>token - The token to expand.</li>
                  
                </ul>
              </section>

              

              <section>
                <p>Find all the possible suffixes of the passed token using tokens currently in the store.</p>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>lunr.TokenStore.prototype.expand = function (token, memo) {
  var root = this.getNode(token),
      docs = root.docs || {},
      memo = memo || []

  if (Object.keys(docs).length) memo.push(token)

  Object.keys(root)
    .forEach(function (key) {
      if (key === 'docs') return

      memo.concat(this.expand(token + key, memo))
    }, this)

  return memo
}</code></pre>
              </section>
              
            </section>
          
            <section class='method' id='toJSON'>
              <header>
                <h3>toJSON</h3>
                <h4>lunr.TokenStore.prototype.toJSON()</h4>
                <p class='type'>method</p>
                
                  <p class='related'>See: <a href='#'>toJSON</a></p>
                
              </header>

              <section class='params'>
                
                <ul>
                  
                </ul>
              </section>

              

              <section>
                <p>Returns a representation of the token store ready for serialisation.</p>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>lunr.TokenStore.prototype.toJSON = function () {
  return {
    root: this.root,
    length: this.length
  }
}</code></pre>
              </section>
              
            </section>
          
        </article>
      
    </div>
  </div>
  <script>
    (function (hijs) {
    //
    // hijs - JavaScript Syntax Highlighter
    //
    // Copyright (c) 2010 Alexis Sellier
    //

    // All elements which match this will be syntax highlighted.
    var selector = hijs || 'code';

    var keywords = ('var function if else for while break switch case do new null in with void '
                   +'continue delete return this true false throw catch typeof with instanceof').split(' '),
        special  = ('eval window document undefined NaN Infinity parseInt parseFloat '
                   +'encodeURI decodeURI encodeURIComponent decodeURIComponent').split(' ');

    // Syntax definition
    // The key becomes the class name of the <span>
    // around the matched block of code.
    var syntax = [
      ['comment', /(\/\*(?:[^*\n]|\*+[^\/*])*\*+\/)/g],
      ['comment', /(\/\/[^\n]*)/g],
      ['string' , /("(?:(?!")[^\\\n]|\\.)*"|'(?:(?!')[^\\\n]|\\.)*')/g],
      ['regexp' , /(\/.+\/[mgi]*)(?!\s*\w)/g],
      ['class'  , /\b([A-Z][a-zA-Z]+)\b/g],
      ['number' , /\b([0-9]+(?:\.[0-9]+)?)\b/g],
      ['keyword', new(RegExp)('\\b(' + keywords.join('|') + ')\\b', 'g')],
      ['special', new(RegExp)('\\b(' + special.join('|') + ')\\b', 'g')]
    ];
    var nodes, table = {};

    if (/^[a-z]+$/.test(selector)) {
        nodes = document.getElementsByTagName(selector);
    } else if (/^\.[\w-]+$/.test(selector)) {
        nodes = document.getElementsByClassName(selector.slice(1));
    } else if (document.querySelectorAll) {
        nodes = document.querySelectorAll(selector);
    } else {
        nodes = [];
    }

    for (var i = 0, children; i < nodes.length; i++) {
        children = nodes[i].childNodes;

        for (var j = 0, str; j < children.length; j++) {
            code = children[j];

            if (code.length >= 0) { // It's a text node
                // Don't highlight command-line snippets
                if (! /^\$/.test(code.nodeValue.trim())) {
                    syntax.forEach(function (s) {
                        var k = s[0], v = s[1];
                        code.nodeValue = code.nodeValue.replace(v, function (_, m) {
                            return '\u00ab' + encode(k) + '\u00b7'
                                            + encode(m) +
                                   '\u00b7' + encode(k) + '\u00bb';
                        });
                    });
                }
            }
        }
    }
    for (var i = 0; i < nodes.length; i++) {
        nodes[i].innerHTML =
            nodes[i].innerHTML.replace(/\u00ab(.+?)\u00b7(.+?)\u00b7\1\u00bb/g, function (_, name, value) {
                value = value.replace(/\u00ab[^\u00b7]+\u00b7/g, '').replace(/\u00b7[^\u00bb]+\u00bb/g, '');
                return '<span class="' + decode(name) + '">' + escape(decode(value)) + '</span>';
        });
    }

    function escape(str) {
        return str.replace(/</g, '&lt;').replace(/>/g, '&gt;');
    }

    // Encode ASCII characters to, and from Braille
    function encode (str, encoded) {
        table[encoded = str.split('').map(function (s) {
            if (s.charCodeAt(0) > 127) { return s }
            return String.fromCharCode(s.charCodeAt(0) + 0x2800);
        }).join('')] = str;
        return encoded;
    }
    function decode (str) {
        if (str in table) {
            return table[str];
        } else {
            return str.trim().split('').map(function (s) {
                if (s.charCodeAt(0) - 0x2800 > 127) { return s }
                return String.fromCharCode(s.charCodeAt(0) - 0x2800);
            }).join('');
        }
    }

    })(window.hijs);
  </script>
</body>
